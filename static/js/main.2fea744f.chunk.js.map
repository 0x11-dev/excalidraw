{"version":3,"sources":["zindex.ts","random.ts","element/newElement.ts","math.ts","element/bounds.ts","element/handlerRectangles.ts","element/collision.ts","element/resizeTest.ts","element/typeChecks.ts","element/generateDraw.ts","element/textWysiwyg.tsx","scene/scrollbars.ts","scene/roundRect.ts","scene/selection.ts","scene/render.ts","scene/data.ts","scene/comparisons.ts","utils.ts","components/EditableText.tsx","components/ButtonSelect.tsx","components/Popover.tsx","components/ColorPicker.tsx","shapes.tsx","components/ContextMenu.tsx","history.ts","index.tsx","scene/createScene.ts"],"names":["swap","elements","indexA","indexB","element","moveOneLeft","indicesToMove","sort","a","b","isSorted","forEach","index","i","moveOneRight","reversedIndicesToMove","length","moveAllLeft","leftMostElements","map","reverse","concat","pos","moveAllRight","rightMostElements","randomSeed","Math","floor","random","withCustomMathRandom","seed","cb","imul","LCG","result","newElement","type","x","y","strokeColor","backgroundColor","fillStyle","strokeWidth","roughness","opacity","width","height","isSelected","draw","rc","context","sceneState","distanceBetweenPointAndSegment","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","hypot","rotate","angle","cos","sin","getElementAbsoluteX1","getElementAbsoluteX2","getElementAbsoluteY1","getElementAbsoluteY2","getDiamondPoints","topX","rightX","rightY","getArrowPoints","distance","minSize","min","xs","ys","PI","x3","y3","handlerRectangles","elementX1","elementX2","elementY1","elementY2","handlers","marginX","marginY","abs","scrollX","scrollY","nw","se","hitTest","px","py","tx","ty","ex","ey","rx","ry","qx","qy","r","q","max","t","topY","bottomX","bottomY","leftX","leftY","x4","y4","console","warn","Error","resizeTest","filter","Object","keys","key","handler","isTextElement","generator","rough","generateDraw","fillRect","shape","rectangle","stroke","fill","globalAlpha","translate","polygon","ellipse","options","shapes","line","font","fillText","text","actualBoundingBoxAscent","textWysiwyg","onSubmit","input","document","createElement","stopEvent","ev","stopPropagation","handleSubmit","value","cleanup","window","removeEventListener","body","removeChild","assign","style","position","top","left","transform","boxShadow","textAlign","innerWidth","fontSize","fontFamily","border","background","onkeydown","KEYS","ESCAPE","ENTER","onblur","addEventListener","appendChild","focus","getScrollBars","canvasWidth","canvasHeight","minX","Infinity","maxX","minY","maxY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","horizontalScrollBar","SCROLLBAR_MARGIN","verticalScrollBar","SCROLLBAR_WIDTH","horizontal","vertical","roundRect","radius","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","clearSelection","deleteSelectedElements","splice","getSelectedIndices","selectedIndices","push","someElementIsSelected","some","getSelectedAttribute","getAttribute","attributes","Array","from","Set","renderScene","canvas","offsetX","offsetY","renderScrollbars","renderSelection","getContext","viewBackgroundColor","clearRect","lineDash","getLineDash","setLineDash","strokeRect","margin","values","scrollBars","devicePixelRatio","strokeStyle","scrollBar","saveFile","name","data","link","setAttribute","click","remove","restore","savedElements","savedState","JSON","parse","undefined","e","saveToLocalStorage","state","localStorage","setItem","stringify","saveToURL","hash","btoa","join","location","replace","getElementAtPosition","hitElement","capitalizeString","str","charAt","toUpperCase","slice","isInputLike","target","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","EditableText","props","edit","this","setState","onChange","className","maxLength","handleEdit","onBlur","handleBlur","onKeyDown","autoFocus","onClick","Component","ButtonSelect","option","Popover","children","onCloseRequest","onContextMenu","preventDefault","ColorPicker","color","React","useState","isActive","setActive","colors","changedColor","hex","onPaste","clipboardData","getData","SHAPES","icon","viewBox","d","shapesShortcutKeys","findShapeByKey","reduce","contextMenuNode","SceneHistory","recording","stateHistory","redoStack","newEntry","entry","newElements","skipRecording","currentEntry","generateCurrentEntry","entryToRestore","pop","restoreEntry","ContextMenu","idx","ContextMenuOption","label","action","getContextMenuNode","div","handleClose","unmountComponentAtNode","params","of","render","history","DEFAULT_PROJECT_NAME","date","Date","year","getFullYear","month","getMonth","day","getDate","hr","getHours","getMinutes","secs","getSeconds","getDateTime","ARROW_LEFT","ARROW_RIGHT","ARROW_DOWN","ARROW_UP","DELETE","BACKSPACE","META_KEY","test","navigator","platform","COPIED_STYLES","isArrowKey","keyCode","resetCursor","documentElement","cursor","addTextElement","textMeasure","measureText","actualBoundingBoxDescent","lastCanvasWidth","lastCanvasHeight","lastMouseUp","App","draggingElement","resizingElement","elementType","exportBackground","currentItemStrokeColor","currentItemBackgroundColor","onResize","forceUpdate","event","step","shiftKey","altKey","code","includes","toLowerCase","redoOnce","undoOnce","metaKey","find","el","pastedElement","clearCanvas","confirm","removeWheelEventListener","changeProperty","callback","changeOpacity","changeStrokeColor","changeBackgroundColor","copyToClipboard","clipboard","writeText","pasteFromClipboard","readText","then","addElementsFromPaste","handleWheel","deltaX","deltaY","saveDebounced","debounce","paste","parsedElements","isArray","parsedElement","split","atob","restoreFromURL","getItem","innerHeight","onCut","setData","onCopy","title","checked","hasStroke","updateProjectName","exportPadding","alert","subCanvasX1","subCanvasX2","subCanvasY1","subCanvasY2","tempCanvas","display","toDataURL","exportAsPNG","serialized","version","source","origin","encodeURIComponent","saveAsJSON","reader","FileReader","accept","onchange","files","readAsText","Promise","resolve","onloadend","readyState","DONE","loadFromJSON","id","ref","passive","scale","clientX","clientY","onMouseDown","button","activeElement","blur","isOverHorizontalScrollBar","isOverVerticalScrollBar","isOverScrollBars","resizeHandle","isDraggingElements","isResizingElements","resizeElement","lastX","lastY","onMouseMove","HTMLElement","selectedElements","sign","selection","selectionX1","selectionX2","selectionY1","selectionY2","setSelection","onMouseUp","onDoubleClick","isRecording","pushEntry","clearRedoStack","resumeRecording","fn","timeout","handle","args","clearTimeout","setTimeout","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.2fea744f.chunk.js","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n}\n\nexport function moveOneRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n  let isSorted = true;\n\n  // We go from right to left to avoid overriding the wrong elements\n  reversedIndicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index + 1, index);\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beggining\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beggining\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\nexport function moveAllRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n\n  // Copy the elements to move\n  const rightMostElements = reversedIndicesToMove.map(index => elements[index]);\n\n  indicesToMove = reversedIndicesToMove\n    // We go from left to right to avoid overriding elements.\n    .reverse()\n    // We last element index for the final marker\n    .concat([elements.length]);\n\n  indicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the left (i - 1) to the current one (index)\n    for (let pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  });\n\n  // The final step\n  rightMostElements.forEach((element, i) => {\n    elements[elements.length - i - 1] = element;\n  });\n}\n","// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316\nexport const LCG = (seed: number) => () =>\n  ((2 ** 31 - 1) & (seed = Math.imul(48271, seed))) / 2 ** 31;\n\nexport function randomSeed() {\n  return Math.floor(Math.random() * 2 ** 31);\n}\n\n// Unfortunately, roughjs doesn't support a seed attribute (https://github.com/pshihn/rough/issues/27).\n// We can achieve the same result by overriding the Math.random function with a\n// pseudo random generator that supports a random seed and swapping it back after.\nexport function withCustomMathRandom<T>(seed: number, cb: () => T): T {\n  const random = Math.random;\n  Math.random = LCG(seed);\n  const result = cb();\n  Math.random = random;\n  return result;\n}\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport { SceneState } from \"../scene/types\";\nimport { randomSeed } from \"../random\";\n\nexport function newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  fillStyle: string,\n  strokeWidth: number,\n  roughness: number,\n  opacity: number,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    type: type,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    isSelected: false,\n    strokeColor: strokeColor,\n    backgroundColor: backgroundColor,\n    fillStyle: fillStyle,\n    strokeWidth: strokeWidth,\n    roughness: roughness,\n    opacity: opacity,\n    seed: randomSeed(),\n    draw(\n      rc: RoughCanvas,\n      context: CanvasRenderingContext2D,\n      sceneState: SceneState\n    ) {}\n  };\n  return element;\n}\n","// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nexport function rotate(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number\n) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n","import { ExcalidrawElement } from \"./types\";\nimport { rotate } from \"../math\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nexport function getElementAbsoluteX1(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x : element.x + element.width;\n}\nexport function getElementAbsoluteX2(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x + element.width : element.x;\n}\nexport function getElementAbsoluteY1(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y : element.y + element.height;\n}\nexport function getElementAbsoluteY2(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y + element.height : element.y;\n}\n\nexport function getDiamondPoints(element: ExcalidrawElement) {\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\n\nexport function getArrowPoints(element: ExcalidrawElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n","import { SceneState } from \"../scene/types\";\nimport { ExcalidrawElement } from \"./types\";\n\nexport function handlerRectangles(\n  element: ExcalidrawElement,\n  sceneState: SceneState\n) {\n  const elementX1 = element.x;\n  const elementX2 = element.x + element.width;\n  const elementY1 = element.y;\n  const elementY2 = element.y + element.height;\n\n  const margin = 4;\n  const minimumSize = 40;\n  const handlers: { [handler: string]: number[] } = {};\n\n  const marginX = element.width < 0 ? 8 : -8;\n  const marginY = element.height < 0 ? 8 : -8;\n\n  if (Math.abs(elementX2 - elementX1) > minimumSize) {\n    handlers[\"n\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY1 - margin + sceneState.scrollY + marginY,\n      8,\n      8\n    ];\n\n    handlers[\"s\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY2 - margin + sceneState.scrollY - marginY,\n      8,\n      8\n    ];\n  }\n\n  if (Math.abs(elementY2 - elementY1) > minimumSize) {\n    handlers[\"w\"] = [\n      elementX1 - margin + sceneState.scrollX + marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n\n    handlers[\"e\"] = [\n      elementX2 - margin + sceneState.scrollX - marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n  }\n\n  handlers[\"nw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // nw\n  handlers[\"ne\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // ne\n  handlers[\"sw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // sw\n  handlers[\"se\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // se\n\n  if (element.type === \"arrow\") {\n    return {\n      nw: handlers.nw,\n      se: handlers.se\n    };\n  }\n\n  return handlers;\n}\n","import { distanceBetweenPointAndSegment } from \"../math\";\n\nimport { ExcalidrawElement } from \"./types\";\nimport {\n  getElementAbsoluteX1,\n  getElementAbsoluteX2,\n  getElementAbsoluteY1,\n  getElementAbsoluteY2,\n  getArrowPoints,\n  getDiamondPoints\n} from \"./bounds\";\n\nexport function hitTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number\n): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n\n    const [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY\n    ] = getDiamondPoints(element);\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n","import { ExcalidrawElement } from \"./types\";\nimport { SceneState } from \"../scene/types\";\n\nimport { handlerRectangles } from \"./handlerRectangles\";\n\nexport function resizeTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n  sceneState: SceneState\n): string | false {\n  if (element.type === \"text\") return false;\n\n  const handlers = handlerRectangles(element, sceneState);\n\n  const filter = Object.keys(handlers).filter(key => {\n    const handler = handlers[key];\n\n    return (\n      x + sceneState.scrollX >= handler[0] &&\n      x + sceneState.scrollX <= handler[0] + handler[2] &&\n      y + sceneState.scrollY >= handler[1] &&\n      y + sceneState.scrollY <= handler[1] + handler[3]\n    );\n  });\n\n  if (filter.length > 0) {\n    return filter[0];\n  }\n\n  return false;\n}\n","import { ExcalidrawElement, ExcalidrawTextElement } from \"./types\";\n\nexport function isTextElement(\n  element: ExcalidrawElement\n): element is ExcalidrawTextElement {\n  return element.type === \"text\";\n}\n","import rough from \"roughjs/bin/wrappers/rough\";\n\nimport { withCustomMathRandom } from \"../random\";\n\nimport { ExcalidrawElement } from \"./types\";\nimport { isTextElement } from \"./typeChecks\";\nimport { getDiamondPoints, getArrowPoints } from \"./bounds\";\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nconst generator = rough.generator(null, null as any);\n\nexport function generateDraw(element: ExcalidrawElement) {\n  if (element.type === \"selection\") {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(\n        element.x + scrollX,\n        element.y + scrollY,\n        element.width,\n        element.height\n      );\n      context.fillStyle = fillStyle;\n    };\n  } else if (element.type === \"rectangle\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      return generator.rectangle(0, 0, element.width, element.height, {\n        stroke: element.strokeColor,\n        fill: element.backgroundColor,\n        fillStyle: element.fillStyle,\n        strokeWidth: element.strokeWidth,\n        roughness: element.roughness\n      });\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"diamond\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      const [\n        topX,\n        topY,\n        rightX,\n        rightY,\n        bottomX,\n        bottomY,\n        leftX,\n        leftY\n      ] = getDiamondPoints(element);\n      return generator.polygon(\n        [\n          [topX, topY],\n          [rightX, rightY],\n          [bottomX, bottomY],\n          [leftX, leftY]\n        ],\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      );\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"ellipse\") {\n    const shape = withCustomMathRandom(element.seed, () =>\n      generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      )\n    );\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const options = {\n      stroke: element.strokeColor,\n      strokeWidth: element.strokeWidth,\n      roughness: element.roughness\n    };\n\n    const shapes = withCustomMathRandom(element.seed, () => [\n      //    \\\n      generator.line(x3, y3, x2, y2, options),\n      // -----\n      generator.line(x1, y1, x2, y2, options),\n      //    /\n      generator.line(x4, y4, x2, y2, options)\n    ]);\n\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      shapes.forEach(shape => rc.draw(shape));\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n    return;\n  } else if (isTextElement(element)) {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      const font = context.font;\n      context.font = element.font;\n      const fillStyle = context.fillStyle;\n      context.fillStyle = element.strokeColor;\n      context.fillText(\n        element.text,\n        element.x + scrollX,\n        element.y + element.actualBoundingBoxAscent + scrollY\n      );\n      context.fillStyle = fillStyle;\n      context.font = font;\n      context.globalAlpha = 1;\n    };\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n","import { KEYS } from \"../index\";\n\nexport function textWysiwyg(\n  x: number,\n  y: number,\n  onSubmit: (text: string) => void\n) {\n  const input = document.createElement(\"input\");\n\n  Object.assign(input.style, {\n    position: \"absolute\",\n    top: y - 8 + \"px\",\n    left: x + \"px\",\n    transform: \"translate(-50%, -50%)\",\n    boxShadow: \"none\",\n    textAlign: \"center\",\n    width: (window.innerWidth - x) * 2 + \"px\",\n    fontSize: \"20px\",\n    fontFamily: \"Virgil\",\n    border: \"none\",\n    background: \"transparent\"\n  });\n\n  input.onkeydown = ev => {\n    if (ev.key === KEYS.ESCAPE) {\n      cleanup();\n      return;\n    }\n    if (ev.key === KEYS.ENTER) {\n      handleSubmit();\n    }\n  };\n  input.onblur = handleSubmit;\n\n  function stopEvent(ev: Event) {\n    ev.stopPropagation();\n  }\n\n  function handleSubmit() {\n    if (input.value) {\n      onSubmit(input.value);\n    }\n    cleanup();\n  }\n\n  function cleanup() {\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    document.body.removeChild(input);\n  }\n\n  window.addEventListener(\"wheel\", stopEvent, true);\n  document.body.appendChild(input);\n  input.focus();\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport {\n  getElementAbsoluteX1,\n  getElementAbsoluteX2,\n  getElementAbsoluteY1,\n  getElementAbsoluteY2\n} from \"../element\";\n\nconst SCROLLBAR_MIN_SIZE = 15;\nconst SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport function getScrollBars(\n  elements: ExcalidrawElement[],\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  let minX = Infinity;\n  let maxX = 0;\n  let minY = Infinity;\n  let maxY = 0;\n\n  elements.forEach(element => {\n    minX = Math.min(minX, getElementAbsoluteX1(element));\n    maxX = Math.max(maxX, getElementAbsoluteX2(element));\n    minY = Math.min(minY, getElementAbsoluteY1(element));\n    maxY = Math.max(maxY, getElementAbsoluteY2(element));\n  });\n\n  minX += scrollX;\n  maxX += scrollX;\n  minY += scrollY;\n  maxY += scrollY;\n  const leftOverflow = Math.max(-minX, 0);\n  const rightOverflow = Math.max(-(canvasWidth - maxX), 0);\n  const topOverflow = Math.max(-minY, 0);\n  const bottomOverflow = Math.max(-(canvasHeight - maxY), 0);\n\n  // horizontal scrollbar\n  let horizontalScrollBar = null;\n  if (leftOverflow || rightOverflow) {\n    horizontalScrollBar = {\n      x: Math.min(\n        leftOverflow + SCROLLBAR_MARGIN,\n        canvasWidth - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      y: canvasHeight - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      width: Math.max(\n        canvasWidth - rightOverflow - leftOverflow - SCROLLBAR_MARGIN * 2,\n        SCROLLBAR_MIN_SIZE\n      ),\n      height: SCROLLBAR_WIDTH\n    };\n  }\n\n  // vertical scrollbar\n  let verticalScrollBar = null;\n  if (topOverflow || bottomOverflow) {\n    verticalScrollBar = {\n      x: canvasWidth - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      y: Math.min(\n        topOverflow + SCROLLBAR_MARGIN,\n        canvasHeight - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      width: SCROLLBAR_WIDTH,\n      height: Math.max(\n        canvasHeight - bottomOverflow - topOverflow - SCROLLBAR_WIDTH * 2,\n        SCROLLBAR_MIN_SIZE\n      )\n    };\n  }\n\n  return {\n    horizontal: horizontalScrollBar,\n    vertical: verticalScrollBar\n  };\n}\n\nexport function isOverScrollBars(\n  elements: ExcalidrawElement[],\n  x: number,\n  y: number,\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  const scrollBars = getScrollBars(\n    elements,\n    canvasWidth,\n    canvasHeight,\n    scrollX,\n    scrollY\n  );\n\n  const [isOverHorizontalScrollBar, isOverVerticalScrollBar] = [\n    scrollBars.horizontal,\n    scrollBars.vertical\n  ].map(\n    scrollBar =>\n      scrollBar &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n  );\n\n  return {\n    isOverHorizontalScrollBar,\n    isOverVerticalScrollBar\n  };\n}\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport function roundRect(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number\n) {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport {\n  getElementAbsoluteX1,\n  getElementAbsoluteX2,\n  getElementAbsoluteY1,\n  getElementAbsoluteY2\n} from \"../element\";\n\nexport function setSelection(\n  elements: ExcalidrawElement[],\n  selection: ExcalidrawElement\n) {\n  const selectionX1 = getElementAbsoluteX1(selection);\n  const selectionX2 = getElementAbsoluteX2(selection);\n  const selectionY1 = getElementAbsoluteY1(selection);\n  const selectionY2 = getElementAbsoluteY2(selection);\n  elements.forEach(element => {\n    const elementX1 = getElementAbsoluteX1(element);\n    const elementX2 = getElementAbsoluteX2(element);\n    const elementY1 = getElementAbsoluteY1(element);\n    const elementY2 = getElementAbsoluteY2(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nexport function clearSelection(elements: ExcalidrawElement[]) {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nexport function deleteSelectedElements(elements: ExcalidrawElement[]) {\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\nexport function getSelectedIndices(elements: ExcalidrawElement[]) {\n  const selectedIndices: number[] = [];\n  elements.forEach((element, index) => {\n    if (element.isSelected) {\n      selectedIndices.push(index);\n    }\n  });\n  return selectedIndices;\n}\n\nexport const someElementIsSelected = (elements: ExcalidrawElement[]) =>\n  elements.some(element => element.isSelected);\n\nexport function getSelectedAttribute<T>(\n  elements: ExcalidrawElement[],\n  getAttribute: (element: ExcalidrawElement) => T\n): T | null {\n  const attributes = Array.from(\n    new Set(\n      elements\n        .filter(element => element.isSelected)\n        .map(element => getAttribute(element))\n    )\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n}\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport { ExcalidrawElement } from \"../element/types\";\nimport {\n  getElementAbsoluteX1,\n  getElementAbsoluteX2,\n  getElementAbsoluteY1,\n  getElementAbsoluteY2,\n  handlerRectangles\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"./types\";\nimport { getScrollBars, SCROLLBAR_COLOR, SCROLLBAR_WIDTH } from \"./scrollbars\";\nimport { getSelectedIndices } from \"./selection\";\n\nexport function renderScene(\n  elements: ExcalidrawElement[],\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    offsetX,\n    offsetY,\n    renderScrollbars = true,\n    renderSelection = true\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n  } = {}\n) {\n  if (!canvas) return;\n  const context = canvas.getContext(\"2d\")!;\n\n  const fillStyle = context.fillStyle;\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  } else {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  const selectedIndices = getSelectedIndices(elements);\n\n  sceneState = {\n    ...sceneState,\n    scrollX: typeof offsetX === \"number\" ? offsetX : sceneState.scrollX,\n    scrollY: typeof offsetY === \"number\" ? offsetY : sceneState.scrollY\n  };\n\n  elements.forEach(element => {\n    element.draw(rc, context, sceneState);\n    if (renderSelection && element.isSelected) {\n      const margin = 4;\n\n      const elementX1 = getElementAbsoluteX1(element);\n      const elementX2 = getElementAbsoluteX2(element);\n      const elementY1 = getElementAbsoluteY1(element);\n      const elementY2 = getElementAbsoluteY2(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin + sceneState.scrollX,\n        elementY1 - margin + sceneState.scrollY,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n\n      if (element.type !== \"text\" && selectedIndices.length === 1) {\n        const handlers = handlerRectangles(element, sceneState);\n        Object.values(handlers).forEach(handler => {\n          context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n        });\n      }\n    }\n  });\n\n  if (renderScrollbars) {\n    const scrollBars = getScrollBars(\n      elements,\n      context.canvas.width / window.devicePixelRatio,\n      context.canvas.height / window.devicePixelRatio,\n      sceneState.scrollX,\n      sceneState.scrollY\n    );\n\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar)\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2\n        );\n    });\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n  }\n}\n","import rough from \"roughjs/bin/wrappers/rough\";\n\nimport { ExcalidrawElement } from \"../element/types\";\n\nimport {\n  getElementAbsoluteX1,\n  getElementAbsoluteX2,\n  getElementAbsoluteY1,\n  getElementAbsoluteY2,\n  generateDraw\n} from \"../element\";\n\nimport { renderScene } from \"./render\";\nimport { AppState } from \"../types\";\n\nconst LOCAL_STORAGE_KEY = \"excalidraw\";\nconst LOCAL_STORAGE_KEY_STATE = \"excalidraw-state\";\n\nfunction saveFile(name: string, data: string) {\n  // create a temporary <a> elem which we'll use to download the image\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"download\", name);\n  link.setAttribute(\"href\", data);\n  link.click();\n\n  // clean up\n  link.remove();\n}\n\nexport function saveAsJSON(elements: ExcalidrawElement[], name: string) {\n  const serialized = JSON.stringify({\n    version: 1,\n    source: window.location.origin,\n    elements\n  });\n\n  saveFile(\n    `${name}.json`,\n    \"data:text/plain;charset=utf-8,\" + encodeURIComponent(serialized)\n  );\n}\n\nexport function loadFromJSON(elements: ExcalidrawElement[]) {\n  const input = document.createElement(\"input\");\n  const reader = new FileReader();\n  input.type = \"file\";\n  input.accept = \".json\";\n\n  input.onchange = () => {\n    if (!input.files!.length) {\n      alert(\"A file was not selected.\");\n      return;\n    }\n\n    reader.readAsText(input.files![0], \"utf8\");\n  };\n\n  input.click();\n\n  return new Promise(resolve => {\n    reader.onloadend = () => {\n      if (reader.readyState === FileReader.DONE) {\n        const data = JSON.parse(reader.result as string);\n        restore(elements, data.elements, null);\n        resolve();\n      }\n    };\n  });\n}\n\nexport function exportAsPNG(\n  elements: ExcalidrawElement[],\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    scrollX: number;\n    scrollY: number;\n    name: string;\n  }\n) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n  // calculate smallest area to fit the contents in\n\n  let subCanvasX1 = Infinity;\n  let subCanvasX2 = 0;\n  let subCanvasY1 = Infinity;\n  let subCanvasY2 = 0;\n\n  elements.forEach(element => {\n    subCanvasX1 = Math.min(subCanvasX1, getElementAbsoluteX1(element));\n    subCanvasX2 = Math.max(subCanvasX2, getElementAbsoluteX2(element));\n    subCanvasY1 = Math.min(subCanvasY1, getElementAbsoluteY1(element));\n    subCanvasY2 = Math.max(subCanvasY2, getElementAbsoluteY2(element));\n  });\n\n  function distance(x: number, y: number) {\n    return Math.abs(x > y ? x - y : y - x);\n  }\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  tempCanvas.width = distance(subCanvasX1, subCanvasX2) + exportPadding * 2;\n  tempCanvas.height = distance(subCanvasY1, subCanvasY2) + exportPadding * 2;\n\n  renderScene(\n    elements,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: 0,\n      scrollY: 0\n    },\n    {\n      offsetX: -subCanvasX1 + exportPadding,\n      offsetY: -subCanvasY1 + exportPadding,\n      renderScrollbars: false,\n      renderSelection: false\n    }\n  );\n\n  saveFile(`${name}.png`, tempCanvas.toDataURL(\"image/png\"));\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) tempCanvas.remove();\n}\n\nfunction restore(\n  elements: ExcalidrawElement[],\n  savedElements: string | ExcalidrawElement[] | null,\n  savedState: string | null\n) {\n  try {\n    if (savedElements) {\n      elements.splice(\n        0,\n        elements.length,\n        ...(typeof savedElements === \"string\"\n          ? JSON.parse(savedElements)\n          : savedElements)\n      );\n      elements.forEach((element: ExcalidrawElement) => {\n        element.fillStyle = element.fillStyle || \"hachure\";\n        element.strokeWidth = element.strokeWidth || 1;\n        element.roughness = element.roughness || 1;\n        element.opacity =\n          element.opacity === null || element.opacity === undefined\n            ? 100\n            : element.opacity;\n\n        generateDraw(element);\n      });\n    }\n\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (e) {\n    elements.splice(0, elements.length);\n    return null;\n  }\n}\n\nexport function restoreFromLocalStorage(elements: ExcalidrawElement[]) {\n  const savedElements = localStorage.getItem(LOCAL_STORAGE_KEY);\n  const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_STATE);\n\n  return restore(elements, savedElements, savedState);\n}\n\nexport function saveToLocalStorage(\n  elements: ExcalidrawElement[],\n  state: AppState\n) {\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(elements));\n  localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(state));\n}\n\nexport function restoreFromURL(elements: ExcalidrawElement[]) {\n  try {\n    const [savedElements, savedState] = document.location.hash\n      .slice(1)\n      .split(\":\")\n      .map(atob);\n    return restore(elements, savedElements, savedState);\n  } catch (ex) {\n    return null;\n  }\n}\n\nexport function saveToURL(elements: ExcalidrawElement[], state: AppState) {\n  const hash = [JSON.stringify(elements), JSON.stringify(state)]\n    .map(btoa)\n    .join(\":\");\n  document.location.replace(\"#\" + hash);\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport { hitTest } from \"../element/collision\";\n\nexport const hasBackground = (elements: ExcalidrawElement[]) =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\")\n  );\n\nexport const hasStroke = (elements: ExcalidrawElement[]) =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\" ||\n        element.type === \"arrow\")\n  );\n\nexport function getElementAtPosition(\n  elements: ExcalidrawElement[],\n  x: number,\n  y: number\n) {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (hitTest(elements[i], x, y)) {\n      hitElement = elements[i];\n      break;\n    }\n  }\n\n  return hitElement;\n}\n","export function getDateTime() {\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const hr = date.getHours();\n  const min = date.getMinutes();\n  const secs = date.getSeconds();\n\n  return `${year}${month}${day}${hr}${min}${secs}`;\n}\n\nexport function capitalizeString(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function isInputLike(\n  target: Element | EventTarget | null\n): target is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\n  return (\n    target instanceof HTMLInputElement ||\n    target instanceof HTMLTextAreaElement ||\n    target instanceof HTMLSelectElement\n  );\n}\n","import React, { Fragment, Component } from \"react\";\n\ntype InputState = {\n  value: string;\n  edit: boolean;\n};\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport class EditableText extends Component<Props, InputState> {\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      value: props.value,\n      edit: false\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(props: Props) {\n    this.setState({ value: props.value });\n  }\n\n  private handleEdit(e: React.ChangeEvent<HTMLInputElement>) {\n    this.setState({ value: e.target.value });\n  }\n\n  private handleBlur() {\n    const { value } = this.state;\n\n    if (!value) {\n      this.setState({ value: this.props.value, edit: false });\n      return;\n    }\n    this.props.onChange(value);\n    this.setState({ edit: false });\n  }\n\n  public render() {\n    const { value, edit } = this.state;\n\n    return (\n      <Fragment>\n        {edit ? (\n          <input\n            className=\"project-name-input\"\n            name=\"name\"\n            maxLength={25}\n            value={value}\n            onChange={e => this.handleEdit(e)}\n            onBlur={() => this.handleBlur()}\n            onKeyDown={e => {\n              if (e.key === \"Enter\") {\n                this.handleBlur();\n              }\n            }}\n            autoFocus\n          />\n        ) : (\n          <span\n            onClick={() => this.setState({ edit: true })}\n            className=\"project-name\"\n          >\n            {value}\n          </span>\n        )}\n      </Fragment>\n    );\n  }\n}\n","import React from \"react\";\n\nexport function ButtonSelect<T>({\n  options,\n  value,\n  onChange\n}: {\n  options: { value: T; text: string }[];\n  value: T | null;\n  onChange: (value: T) => void;\n}) {\n  return (\n    <div className=\"buttonList\">\n      {options.map(option => (\n        <button\n          key={option.text}\n          onClick={() => onChange(option.value)}\n          className={value === option.value ? \"active\" : \"\"}\n        >\n          {option.text}\n        </button>\n      ))}\n    </div>\n  );\n}\n","import React from \"react\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(): void;\n};\n\nexport function Popover({ children, left, onCloseRequest, top }: Props) {\n  return (\n    <div className=\"popover\" style={{ top: top, left: left }}>\n      <div\n        className=\"cover\"\n        onClick={onCloseRequest}\n        onContextMenu={e => {\n          e.preventDefault();\n          if (onCloseRequest) onCloseRequest();\n        }}\n      />\n      {children}\n    </div>\n  );\n}\n","import React from \"react\";\nimport { TwitterPicker } from \"react-color\";\nimport { Popover } from \"./Popover\";\n\nexport function ColorPicker({\n  color,\n  onChange\n}: {\n  color: string | null;\n  onChange: (color: string) => void;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  return (\n    <div>\n      <button\n        className=\"swatch\"\n        style={color ? { backgroundColor: color } : undefined}\n        onClick={() => setActive(!isActive)}\n      />\n      {isActive ? (\n        <Popover onCloseRequest={() => setActive(false)}>\n          <TwitterPicker\n            colors={[\n              \"#000000\",\n              \"#ABB8C3\",\n              \"#FFFFFF\",\n              \"#FF6900\",\n              \"#FCB900\",\n              \"#00D084\",\n              \"#8ED1FC\",\n              \"#0693E3\",\n              \"#EB144C\",\n              \"#F78DA7\",\n              \"#9900EF\"\n            ]}\n            width=\"205px\"\n            color={color || undefined}\n            onChange={changedColor => {\n              onChange(changedColor.hex);\n            }}\n          />\n        </Popover>\n      ) : null}\n      <input\n        type=\"text\"\n        className=\"swatch-input\"\n        value={color || \"\"}\n        onPaste={e => onChange(e.clipboardData.getData(\"text\"))}\n        onChange={e => onChange(e.target.value)}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nexport const SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\"\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\"\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\"\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\"\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\"\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\"\n  }\n];\n\nexport const shapesShortcutKeys = SHAPES.map(shape => shape.value[0]);\n\nexport function findShapeByKey(key: string) {\n  const defaultElement = \"selection\";\n  return SHAPES.reduce((element, shape) => {\n    if (shape.value[0] !== key) return element;\n\n    return shape.value;\n  }, defaultElement);\n}\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\n\nimport \"./ContextMenu.css\";\n\ntype ContextMenuOption = {\n  label: string;\n  action(): void;\n};\n\ntype Props = {\n  options: ContextMenuOption[];\n  onCloseRequest?(): void;\n  top: number;\n  left: number;\n};\n\nfunction ContextMenu({ options, onCloseRequest, top, left }: Props) {\n  return (\n    <Popover onCloseRequest={onCloseRequest} top={top} left={left}>\n      <ul className=\"context-menu\" onContextMenu={e => e.preventDefault()}>\n        {options.map((option, idx) => (\n          <li\n            key={idx}\n            className=\"context-menu__option\"\n            onClick={onCloseRequest}\n          >\n            <ContextMenuOption {...option} />\n          </li>\n        ))}\n      </ul>\n    </Popover>\n  );\n}\n\nfunction ContextMenuOption({ label, action }: ContextMenuOption) {\n  return (\n    <button className=\"context-menu-option\" onClick={action}>\n      {label}\n    </button>\n  );\n}\n\nlet contextMenuNode: HTMLDivElement;\nfunction getContextMenuNode(): HTMLDivElement {\n  if (contextMenuNode) {\n    return contextMenuNode;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  return (contextMenuNode = div);\n}\n\ntype ContextMenuParams = {\n  options: (ContextMenuOption | false | null | undefined)[];\n  top: number;\n  left: number;\n};\n\nfunction handleClose() {\n  unmountComponentAtNode(getContextMenuNode());\n}\n\nexport default {\n  push(params: ContextMenuParams) {\n    const options = Array.of<ContextMenuOption>();\n    params.options.forEach(option => {\n      if (option) {\n        options.push(option);\n      }\n    });\n    if (options.length) {\n      render(\n        <ContextMenu\n          top={params.top}\n          left={params.left}\n          options={options}\n          onCloseRequest={handleClose}\n        />,\n        getContextMenuNode()\n      );\n    }\n  }\n};\n","import { ExcalidrawElement } from \"./element/types\";\nimport { generateDraw } from \"./element\";\n\nclass SceneHistory {\n  private recording: boolean = true;\n  private stateHistory: string[] = [];\n  private redoStack: string[] = [];\n\n  generateCurrentEntry(elements: ExcalidrawElement[]) {\n    return JSON.stringify(\n      elements.map(element => ({ ...element, isSelected: false }))\n    );\n  }\n\n  pushEntry(newEntry: string) {\n    if (\n      this.stateHistory.length > 0 &&\n      this.stateHistory[this.stateHistory.length - 1] === newEntry\n    ) {\n      // If the last entry is the same as this one, ignore it\n      return;\n    }\n    this.stateHistory.push(newEntry);\n  }\n\n  restoreEntry(elements: ExcalidrawElement[], entry: string) {\n    const newElements = JSON.parse(entry);\n    elements.splice(0, elements.length);\n    newElements.forEach((newElement: ExcalidrawElement) => {\n      generateDraw(newElement);\n      elements.push(newElement);\n    });\n    // When restoring, we shouldn't add an history entry otherwise we'll be stuck with it and can't go back\n    this.skipRecording();\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(elements: ExcalidrawElement[]) {\n    const currentEntry = this.generateCurrentEntry(elements);\n    const entryToRestore = this.redoStack.pop();\n    if (entryToRestore !== undefined) {\n      this.restoreEntry(elements, entryToRestore);\n      this.stateHistory.push(currentEntry);\n    }\n  }\n\n  undoOnce(elements: ExcalidrawElement[]) {\n    const currentEntry = this.generateCurrentEntry(elements);\n    let entryToRestore = this.stateHistory.pop();\n\n    // If nothing was changed since last, take the previous one\n    if (currentEntry === entryToRestore) {\n      entryToRestore = this.stateHistory.pop();\n    }\n    if (entryToRestore !== undefined) {\n      this.restoreEntry(elements, entryToRestore);\n      this.redoStack.push(currentEntry);\n    }\n  }\n\n  isRecording() {\n    return this.recording;\n  }\n\n  skipRecording() {\n    this.recording = false;\n  }\n\n  resumeRecording() {\n    this.recording = true;\n  }\n}\n\nexport const createHistory: () => { history: SceneHistory } = () => {\n  const history = new SceneHistory();\n  return { history };\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport rough from \"roughjs/bin/wrappers/rough\";\n\nimport { moveOneLeft, moveAllLeft, moveOneRight, moveAllRight } from \"./zindex\";\nimport { randomSeed } from \"./random\";\nimport {\n  newElement,\n  resizeTest,\n  generateDraw,\n  isTextElement,\n  textWysiwyg\n} from \"./element\";\nimport {\n  renderScene,\n  clearSelection,\n  getSelectedIndices,\n  deleteSelectedElements,\n  setSelection,\n  isOverScrollBars,\n  someElementIsSelected,\n  getSelectedAttribute,\n  loadFromJSON,\n  saveAsJSON,\n  exportAsPNG,\n  restoreFromLocalStorage,\n  saveToLocalStorage,\n  restoreFromURL,\n  saveToURL,\n  hasBackground,\n  hasStroke,\n  getElementAtPosition,\n  createScene\n} from \"./scene\";\nimport { AppState } from \"./types\";\nimport { ExcalidrawElement, ExcalidrawTextElement } from \"./element/types\";\n\nimport { getDateTime, capitalizeString, isInputLike } from \"./utils\";\n\nimport { EditableText } from \"./components/EditableText\";\nimport { ButtonSelect } from \"./components/ButtonSelect\";\nimport { ColorPicker } from \"./components/ColorPicker\";\nimport { SHAPES, findShapeByKey, shapesShortcutKeys } from \"./shapes\";\nimport { createHistory } from \"./history\";\n\nimport \"./styles.scss\";\nimport ContextMenu from \"./components/ContextMenu\";\n\nconst { elements } = createScene();\nconst { history } = createHistory();\n\nconst DEFAULT_PROJECT_NAME = `excalidraw-${getDateTime()}`;\n\nconst CANVAS_WINDOW_OFFSET_LEFT = 250;\nconst CANVAS_WINDOW_OFFSET_TOP = 0;\n\nexport const KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ESCAPE: \"Escape\",\n  ENTER: \"Enter\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\nconst META_KEY = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n  ? \"metaKey\"\n  : \"ctrlKey\";\n\nlet COPIED_STYLES: string = \"{}\";\n\nfunction isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n\nfunction resetCursor() {\n  document.documentElement.style.cursor = \"\";\n}\n\nfunction addTextElement(element: ExcalidrawTextElement, text = \"\") {\n  resetCursor();\n  if (text === null || text === \"\") {\n    return false;\n  }\n  const fontSize = 20;\n  element.text = text;\n  element.font = `${fontSize}px Virgil`;\n  const font = context.font;\n  context.font = element.font;\n  const textMeasure = context.measureText(element.text);\n  const width = textMeasure.width;\n  const actualBoundingBoxAscent =\n    textMeasure.actualBoundingBoxAscent || fontSize;\n  const actualBoundingBoxDescent = textMeasure.actualBoundingBoxDescent || 0;\n  element.actualBoundingBoxAscent = actualBoundingBoxAscent;\n  context.font = font;\n  const height = actualBoundingBoxAscent + actualBoundingBoxDescent;\n  // Center the text\n  element.x -= width / 2;\n  element.y -= actualBoundingBoxAscent;\n  element.width = width;\n  element.height = height;\n\n  return true;\n}\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\n\nlet lastCanvasWidth = -1;\nlet lastCanvasHeight = -1;\n\nlet lastMouseUp: ((e: any) => void) | null = null;\n\nclass App extends React.Component<{}, AppState> {\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    window.addEventListener(\"resize\", this.onResize, false);\n\n    const savedState =\n      restoreFromURL(elements) || restoreFromLocalStorage(elements);\n    if (savedState) {\n      this.setState(savedState);\n    }\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    window.removeEventListener(\"resize\", this.onResize, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    resizingElement: null,\n    elementType: \"selection\",\n    exportBackground: true,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    viewBackgroundColor: \"#ffffff\",\n    scrollX: 0,\n    scrollY: 0,\n    name: DEFAULT_PROJECT_NAME\n  };\n\n  private onResize = () => {\n    this.forceUpdate();\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (isInputLike(event.target)) return;\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection(elements);\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      this.deleteSelectedElements();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send backward: Cmd-Shift-Alt-B\n    } else if (\n      event[META_KEY] &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyB\"\n    ) {\n      this.moveOneLeft();\n      event.preventDefault();\n\n      // Send to back: Cmd-Shift-B\n    } else if (event[META_KEY] && event.shiftKey && event.code === \"KeyB\") {\n      this.moveAllLeft();\n      event.preventDefault();\n\n      // Bring forward: Cmd-Shift-Alt-F\n    } else if (\n      event[META_KEY] &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyF\"\n    ) {\n      this.moveOneRight();\n      event.preventDefault();\n\n      // Bring to front: Cmd-Shift-F\n    } else if (event[META_KEY] && event.shiftKey && event.code === \"KeyF\") {\n      this.moveAllRight();\n      event.preventDefault();\n      // Select all: Cmd-A\n    } else if (event[META_KEY] && event.code === \"KeyA\") {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n      this.setState({ elementType: findShapeByKey(event.key) });\n    } else if (event[META_KEY] && event.code === \"KeyZ\") {\n      if (event.shiftKey) {\n        // Redo action\n        history.redoOnce(elements);\n      } else {\n        // undo action\n        history.undoOnce(elements);\n      }\n      this.forceUpdate();\n      event.preventDefault();\n      // Copy Styles: Cmd-Shift-C\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyC\") {\n      const element = elements.find(el => el.isSelected);\n      if (element) {\n        COPIED_STYLES = JSON.stringify(element);\n      }\n      // Paste Styles: Cmd-Shift-V\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyV\") {\n      const pastedElement = JSON.parse(COPIED_STYLES);\n      if (pastedElement.type) {\n        elements.forEach(element => {\n          if (element.isSelected) {\n            element.backgroundColor = pastedElement?.backgroundColor;\n            element.strokeWidth = pastedElement?.strokeWidth;\n            element.strokeColor = pastedElement?.strokeColor;\n            element.fillStyle = pastedElement?.fillStyle;\n            element.opacity = pastedElement?.opacity;\n            generateDraw(element);\n          }\n        });\n      }\n      this.forceUpdate();\n      event.preventDefault();\n    }\n  };\n\n  private deleteSelectedElements = () => {\n    deleteSelectedElements(elements);\n    this.forceUpdate();\n  };\n\n  private clearCanvas = () => {\n    if (window.confirm(\"This will clear the whole canvas. Are you sure?\")) {\n      elements.splice(0, elements.length);\n      this.setState({\n        viewBackgroundColor: \"#ffffff\",\n        scrollX: 0,\n        scrollY: 0\n      });\n      this.forceUpdate();\n    }\n  };\n\n  private moveAllLeft = () => {\n    moveAllLeft(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveOneLeft = () => {\n    moveOneLeft(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveAllRight = () => {\n    moveAllRight(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveOneRight = () => {\n    moveOneRight(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private removeWheelEventListener: (() => void) | undefined;\n\n  private updateProjectName(name: string): void {\n    this.setState({ name });\n  }\n\n  private changeProperty = (callback: (element: ExcalidrawElement) => void) => {\n    elements.forEach(element => {\n      if (element.isSelected) {\n        callback(element);\n        generateDraw(element);\n      }\n    });\n\n    this.forceUpdate();\n  };\n\n  private changeOpacity = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.changeProperty(element => (element.opacity = +event.target.value));\n  };\n\n  private changeStrokeColor = (color: string) => {\n    this.changeProperty(element => (element.strokeColor = color));\n    this.setState({ currentItemStrokeColor: color });\n  };\n\n  private changeBackgroundColor = (color: string) => {\n    this.changeProperty(element => (element.backgroundColor = color));\n    this.setState({ currentItemBackgroundColor: color });\n  };\n\n  private copyToClipboard = () => {\n    if (navigator.clipboard) {\n      const text = JSON.stringify(\n        elements.filter(element => element.isSelected)\n      );\n      navigator.clipboard.writeText(text);\n    }\n  };\n\n  private pasteFromClipboard = (x?: number, y?: number) => {\n    if (navigator.clipboard) {\n      navigator.clipboard\n        .readText()\n        .then(text => this.addElementsFromPaste(text, x, y));\n    }\n  };\n\n  public render() {\n    const canvasWidth = window.innerWidth - CANVAS_WINDOW_OFFSET_LEFT;\n    const canvasHeight = window.innerHeight - CANVAS_WINDOW_OFFSET_TOP;\n\n    return (\n      <div\n        className=\"container\"\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements(elements);\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          this.addElementsFromPaste(paste);\n          e.preventDefault();\n        }}\n      >\n        <div className=\"sidePanel\">\n          <h4>Shapes</h4>\n          <div className=\"panelTools\">\n            {SHAPES.map(({ value, icon }) => (\n              <label\n                key={value}\n                className=\"tool\"\n                title={`${capitalizeString(value)} - ${\n                  capitalizeString(value)[0]\n                }`}\n              >\n                <input\n                  type=\"radio\"\n                  checked={this.state.elementType === value}\n                  onChange={() => {\n                    this.setState({ elementType: value });\n                    clearSelection(elements);\n                    document.documentElement.style.cursor =\n                      value === \"text\" ? \"text\" : \"crosshair\";\n                    this.forceUpdate();\n                  }}\n                />\n                <div className=\"toolIcon\">{icon}</div>\n              </label>\n            ))}\n          </div>\n          {someElementIsSelected(elements) && (\n            <div className=\"panelColumn\">\n              <h4>Selection</h4>\n              <div className=\"buttonList\">\n                <button onClick={this.moveOneRight}>Bring forward</button>\n                <button onClick={this.moveAllRight}>Bring to front</button>\n                <button onClick={this.moveOneLeft}>Send backward</button>\n                <button onClick={this.moveAllLeft}>Send to back</button>\n              </div>\n              <h5>Stroke Color</h5>\n              <ColorPicker\n                color={getSelectedAttribute(\n                  elements,\n                  element => element.strokeColor\n                )}\n                onChange={color => this.changeStrokeColor(color)}\n              />\n\n              {hasBackground(elements) && (\n                <>\n                  <h5>Background Color</h5>\n                  <ColorPicker\n                    color={getSelectedAttribute(\n                      elements,\n                      element => element.backgroundColor\n                    )}\n                    onChange={color => this.changeBackgroundColor(color)}\n                  />\n                  <h5>Fill</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: \"solid\", text: \"Solid\" },\n                      { value: \"hachure\", text: \"Hachure\" },\n                      { value: \"cross-hatch\", text: \"Cross-hatch\" }\n                    ]}\n                    value={getSelectedAttribute(\n                      elements,\n                      element => element.fillStyle\n                    )}\n                    onChange={value => {\n                      this.changeProperty(element => {\n                        element.fillStyle = value;\n                      });\n                    }}\n                  />\n                </>\n              )}\n\n              {hasStroke(elements) && (\n                <>\n                  <h5>Stroke Width</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: 1, text: \"Thin\" },\n                      { value: 2, text: \"Bold\" },\n                      { value: 4, text: \"Extra Bold\" }\n                    ]}\n                    value={getSelectedAttribute(\n                      elements,\n                      element => element.strokeWidth\n                    )}\n                    onChange={value => {\n                      this.changeProperty(element => {\n                        element.strokeWidth = value;\n                      });\n                    }}\n                  />\n\n                  <h5>Sloppiness</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: 0, text: \"Draftsman\" },\n                      { value: 1, text: \"Artist\" },\n                      { value: 3, text: \"Cartoonist\" }\n                    ]}\n                    value={getSelectedAttribute(\n                      elements,\n                      element => element.roughness\n                    )}\n                    onChange={value =>\n                      this.changeProperty(element => {\n                        element.roughness = value;\n                      })\n                    }\n                  />\n                </>\n              )}\n\n              <h5>Opacity</h5>\n              <input\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                onChange={this.changeOpacity}\n                value={\n                  getSelectedAttribute(elements, element => element.opacity) ||\n                  0 /* Put the opacity at 0 if there are two conflicting ones */\n                }\n              />\n\n              <button onClick={this.deleteSelectedElements}>\n                Delete selected\n              </button>\n            </div>\n          )}\n          <h4>Canvas</h4>\n          <div className=\"panelColumn\">\n            <h5>Canvas Background Color</h5>\n            <ColorPicker\n              color={this.state.viewBackgroundColor}\n              onChange={color => this.setState({ viewBackgroundColor: color })}\n            />\n            <button\n              onClick={this.clearCanvas}\n              title=\"Clear the canvas & reset background color\"\n            >\n              Clear canvas\n            </button>\n          </div>\n          <h4>Export</h4>\n          <div className=\"panelColumn\">\n            <h5>Name</h5>\n            {this.state.name && (\n              <EditableText\n                value={this.state.name}\n                onChange={(name: string) => this.updateProjectName(name)}\n              />\n            )}\n            <h5>Image</h5>\n            <button\n              onClick={() => {\n                exportAsPNG(elements, canvas, this.state);\n              }}\n            >\n              Export to png\n            </button>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={this.state.exportBackground}\n                onChange={e => {\n                  this.setState({ exportBackground: e.target.checked });\n                }}\n              />\n              background\n            </label>\n            <h5>Scene</h5>\n            <button\n              onClick={() => {\n                saveAsJSON(elements, this.state.name);\n              }}\n            >\n              Save as...\n            </button>\n            <button\n              onClick={() => {\n                loadFromJSON(elements).then(() => this.forceUpdate());\n              }}\n            >\n              Load file...\n            </button>\n          </div>\n        </div>\n        <canvas\n          id=\"canvas\"\n          style={{\n            width: canvasWidth,\n            height: canvasHeight\n          }}\n          width={canvasWidth * window.devicePixelRatio}\n          height={canvasHeight * window.devicePixelRatio}\n          ref={canvas => {\n            if (this.removeWheelEventListener) {\n              this.removeWheelEventListener();\n              this.removeWheelEventListener = undefined;\n            }\n            if (canvas) {\n              canvas.addEventListener(\"wheel\", this.handleWheel, {\n                passive: false\n              });\n              this.removeWheelEventListener = () =>\n                canvas.removeEventListener(\"wheel\", this.handleWheel);\n\n              // Whenever React sets the width/height of the canvas element,\n              // the context loses the scale transform. We need to re-apply it\n              if (\n                canvasWidth !== lastCanvasWidth ||\n                canvasHeight !== lastCanvasHeight\n              ) {\n                lastCanvasWidth = canvasWidth;\n                lastCanvasHeight = canvasHeight;\n                canvas\n                  .getContext(\"2d\")!\n                  .scale(window.devicePixelRatio, window.devicePixelRatio);\n              }\n            }\n          }}\n          onContextMenu={e => {\n            e.preventDefault();\n\n            const x =\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n            const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n\n            const element = getElementAtPosition(elements, x, y);\n            if (!element) {\n              ContextMenu.push({\n                options: [\n                  navigator.clipboard && {\n                    label: \"Paste\",\n                    action: () => this.pasteFromClipboard(x, y)\n                  }\n                ],\n                top: e.clientY,\n                left: e.clientX\n              });\n              return;\n            }\n\n            if (!element.isSelected) {\n              clearSelection(elements);\n              element.isSelected = true;\n              this.forceUpdate();\n            }\n\n            ContextMenu.push({\n              options: [\n                navigator.clipboard && {\n                  label: \"Copy\",\n                  action: this.copyToClipboard\n                },\n                navigator.clipboard && {\n                  label: \"Paste\",\n                  action: () => this.pasteFromClipboard(x, y)\n                },\n                { label: \"Delete\", action: this.deleteSelectedElements },\n                { label: \"Move Forward\", action: this.moveOneRight },\n                { label: \"Send to Front\", action: this.moveAllRight },\n                { label: \"Move Backwards\", action: this.moveOneLeft },\n                { label: \"Send to Back\", action: this.moveAllLeft }\n              ],\n              top: e.clientY,\n              left: e.clientX\n            });\n          }}\n          onMouseDown={e => {\n            if (lastMouseUp !== null) {\n              // Unfortunately, sometimes we don't get a mouseup after a mousedown,\n              // this can happen when a contextual menu or alert is triggered. In order to avoid\n              // being in a weird state, we clean up on the next mousedown\n              lastMouseUp(e);\n            }\n            // only handle left mouse button\n            if (e.button !== 0) return;\n            // fixes mousemove causing selection of UI texts #32\n            e.preventDefault();\n            // Preventing the event above disables default behavior\n            //  of defocusing potentially focused input, which is what we want\n            //  when clicking inside the canvas.\n            if (isInputLike(document.activeElement)) {\n              document.activeElement.blur();\n            }\n\n            // Handle scrollbars dragging\n            const {\n              isOverHorizontalScrollBar,\n              isOverVerticalScrollBar\n            } = isOverScrollBars(\n              elements,\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT,\n              e.clientY - CANVAS_WINDOW_OFFSET_TOP,\n              canvasWidth,\n              canvasHeight,\n              this.state.scrollX,\n              this.state.scrollY\n            );\n\n            const x =\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n            const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            );\n            let resizeHandle: string | false = false;\n            let isDraggingElements = false;\n            let isResizingElements = false;\n            if (this.state.elementType === \"selection\") {\n              const resizeElement = elements.find(element => {\n                return resizeTest(element, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n              });\n\n              this.setState({\n                resizingElement: resizeElement ? resizeElement : null\n              });\n\n              if (resizeElement) {\n                resizeHandle = resizeTest(resizeElement, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n                document.documentElement.style.cursor = `${resizeHandle}-resize`;\n                isResizingElements = true;\n              } else {\n                const hitElement = getElementAtPosition(elements, x, y);\n\n                // If we click on something\n                if (hitElement) {\n                  if (hitElement.isSelected) {\n                    // If that element is not already selected, do nothing,\n                    // we're likely going to drag it\n                  } else {\n                    // We unselect every other elements unless shift is pressed\n                    if (!e.shiftKey) {\n                      clearSelection(elements);\n                    }\n                    // No matter what, we select it\n                    hitElement.isSelected = true;\n                  }\n                } else {\n                  // If we don't click on anything, let's remove all the selected elements\n                  clearSelection(elements);\n                }\n\n                isDraggingElements = someElementIsSelected(elements);\n\n                if (isDraggingElements) {\n                  document.documentElement.style.cursor = \"move\";\n                }\n              }\n            }\n\n            if (isTextElement(element)) {\n              textWysiwyg(e.clientX, e.clientY, text => {\n                addTextElement(element, text);\n                generateDraw(element);\n                elements.push(element);\n                element.isSelected = true;\n\n                this.setState({\n                  draggingElement: null,\n                  elementType: \"selection\"\n                });\n              });\n              return;\n            }\n\n            generateDraw(element);\n            elements.push(element);\n            this.setState({ draggingElement: element });\n\n            let lastX = x;\n            let lastY = y;\n\n            if (isOverHorizontalScrollBar || isOverVerticalScrollBar) {\n              lastX = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n              lastY = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n            }\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isOverHorizontalScrollBar) {\n                const x = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n                const dx = x - lastX;\n                this.setState(state => ({ scrollX: state.scrollX - dx }));\n                lastX = x;\n                return;\n              }\n\n              if (isOverVerticalScrollBar) {\n                const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n                const dy = y - lastY;\n                this.setState(state => ({ scrollY: state.scrollY - dy }));\n                lastY = y;\n                return;\n              }\n\n              if (isResizingElements && this.state.resizingElement) {\n                const el = this.state.resizingElement;\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length === 1) {\n                  const x =\n                    e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n                  const y =\n                    e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    switch (resizeHandle) {\n                      case \"nw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        if (e.shiftKey) {\n                          element.y += element.height - element.width;\n                          element.height = element.width;\n                        } else {\n                          element.height += element.y - lastY;\n                          element.y = lastY;\n                        }\n                        break;\n                      case \"ne\":\n                        element.width = lastX - element.x;\n                        if (e.shiftKey) {\n                          element.y += element.height - element.width;\n                          element.height = element.width;\n                        } else {\n                          element.height += element.y - lastY;\n                          element.y = lastY;\n                        }\n                        break;\n                      case \"sw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height = lastY - element.y;\n                        }\n                        break;\n                      case \"se\":\n                        element.width += x - lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height += y - lastY;\n                        }\n                        break;\n                      case \"n\":\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"w\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        break;\n                      case \"s\":\n                        element.height = lastY - element.y;\n                        break;\n                      case \"e\":\n                        element.width = lastX - element.x;\n                        break;\n                    }\n\n                    el.x = element.x;\n                    el.y = element.y;\n                    generateDraw(el);\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when resizing an element\n                  history.skipRecording();\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const x =\n                    e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n                  const y =\n                    e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when dragging an element to initially size it\n                  history.skipRecording();\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width =\n                e.clientX -\n                CANVAS_WINDOW_OFFSET_LEFT -\n                draggingElement.x -\n                this.state.scrollX;\n              let height =\n                e.clientY -\n                CANVAS_WINDOW_OFFSET_TOP -\n                draggingElement.y -\n                this.state.scrollY;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey\n                ? Math.abs(width) * Math.sign(height)\n                : height;\n\n              generateDraw(draggingElement);\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(elements, draggingElement);\n              }\n              // We don't want to save history when moving an element\n              history.skipRecording();\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              lastMouseUp = null;\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              resetCursor();\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection(elements);\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            lastMouseUp = onMouseUp;\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            // We don't want to save history on mouseDown, only on mouseUp when it's fully configured\n            history.skipRecording();\n            this.forceUpdate();\n          }}\n          onDoubleClick={e => {\n            const x =\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n            const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n\n            if (getElementAtPosition(elements, x, y)) {\n              return;\n            }\n\n            const element = newElement(\n              \"text\",\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            );\n\n            textWysiwyg(e.clientX, e.clientY, text => {\n              addTextElement(element as ExcalidrawTextElement, text);\n              generateDraw(element);\n              elements.push(element);\n              element.isSelected = true;\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n            });\n          }}\n        />\n      </div>\n    );\n  }\n\n  private handleWheel = (e: WheelEvent) => {\n    e.preventDefault();\n    const { deltaX, deltaY } = e;\n    this.setState(state => ({\n      scrollX: state.scrollX - deltaX,\n      scrollY: state.scrollY - deltaY\n    }));\n  };\n\n  private saveDebounced = debounce(() => {\n    saveToLocalStorage(elements, this.state);\n    saveToURL(elements, this.state);\n  }, 300);\n\n  private addElementsFromPaste = (paste: string, x?: number, y?: number) => {\n    let parsedElements;\n    try {\n      parsedElements = JSON.parse(paste);\n    } catch (e) {}\n    if (\n      Array.isArray(parsedElements) &&\n      parsedElements.length > 0 &&\n      parsedElements[0].type // need to implement a better check here...\n    ) {\n      clearSelection(elements);\n\n      let dx: number;\n      let dy: number;\n      if (x) {\n        let minX = Math.min(...parsedElements.map(element => element.x));\n        dx = x - minX;\n      }\n      if (y) {\n        let minY = Math.min(...parsedElements.map(element => element.y));\n        dy = y - minY;\n      }\n\n      parsedElements.forEach(parsedElement => {\n        parsedElement.x = dx ? parsedElement.x + dx : 10 - this.state.scrollX;\n        parsedElement.y = dy ? parsedElement.y + dy : 10 - this.state.scrollY;\n        parsedElement.seed = randomSeed();\n        generateDraw(parsedElement);\n        elements.push(parsedElement);\n      });\n      this.forceUpdate();\n    }\n  };\n\n  componentDidUpdate() {\n    renderScene(elements, rc, canvas, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor\n    });\n    this.saveDebounced();\n    if (history.isRecording()) {\n      history.pushEntry(history.generateCurrentEntry(elements));\n      history.clearRedoStack();\n    }\n    history.resumeRecording();\n  }\n}\n\nfunction debounce<T extends any[]>(fn: (...args: T) => void, timeout: number) {\n  let handle = 0;\n  return (...args: T) => {\n    clearTimeout(handle);\n    handle = window.setTimeout(() => fn(...args), timeout);\n  };\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst rc = rough.canvas(canvas);\nconst context = canvas.getContext(\"2d\")!;\n\nReactDOM.render(<App />, rootElement);\n","import { ExcalidrawElement } from \"../element/types\";\n\nexport const createScene = () => {\n  const elements = Array.of<ExcalidrawElement>();\n  return { elements };\n};\n"],"sourceRoot":""}