{"version":3,"sources":["zindex.ts","random.ts","element/newElement.ts","math.ts","element/bounds.ts","element/handlerRectangles.ts","element/collision.ts","element/resizeTest.ts","element/typeChecks.ts","keys.ts","element/textWysiwyg.tsx","scene/scrollbars.ts","scene/selection.ts","renderer/roundRect.ts","renderer/renderElement.ts","renderer/renderScene.ts","scene/data.ts","scene/comparisons.ts","utils.ts","components/ButtonSelect.tsx","shapes.tsx","history.ts","components/Popover.tsx","components/ContextMenu.tsx","components/Panel.tsx","components/panels/PanelTools.tsx","components/panels/PanelSelection.tsx","components/ColorPicker.tsx","components/panels/PanelColor.tsx","components/EditableText.tsx","components/panels/PanelExport.tsx","components/panels/PanelCanvas.tsx","index.tsx","scene/createScene.ts"],"names":["swap","elements","indexA","indexB","element","moveOneLeft","indicesToMove","sort","a","b","isSorted","forEach","index","i","moveOneRight","reversedIndicesToMove","length","moveAllLeft","leftMostElements","map","reverse","concat","pos","moveAllRight","rightMostElements","randomSeed","Math","floor","random","withCustomMathRandom","seed","cb","imul","LCG","result","newElement","type","x","y","strokeColor","backgroundColor","fillStyle","strokeWidth","roughness","opacity","width","height","id","nanoid","isSelected","duplicateElement","copy","distanceBetweenPointAndSegment","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","hypot","rotate","angle","cos","sin","getElementAbsoluteCoords","getDiamondPoints","topX","rightX","rightY","getArrowPoints","distance","minSize","min","xs","ys","PI","x3","y3","handlerRectangles","scrollX","scrollY","elementX1","elementX2","elementY1","elementY2","handlers","marginX","marginY","abs","nw","se","hitTest","px","py","tx","ty","ex","ey","rx","ry","qx","qy","r","q","max","t","topY","bottomX","bottomY","leftX","leftY","x4","y4","console","warn","Error","resizeTest","filter","Object","keys","key","handler","getElementWithResizeHandler","reduce","resizeHandle","isTextElement","KEYS","META_KEY","test","window","navigator","platform","isArrowKey","keyCode","textWysiwyg","initText","font","onSubmit","editable","document","createElement","stopEvent","ev","stopPropagation","handleSubmit","innerText","cleanup","onblur","onkeydown","removeEventListener","body","removeChild","contentEditable","tabIndex","dataset","assign","style","color","position","top","left","transform","textAlign","display","padding","outline","whiteSpace","preventDefault","addEventListener","appendChild","focus","selection","getSelection","range","createRange","selectNodeContents","removeAllRanges","addRange","getScrollBars","canvasWidth","canvasHeight","minX","Infinity","maxX","minY","maxY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","horizontalScrollBar","SCROLLBAR_MARGIN","verticalScrollBar","SCROLLBAR_WIDTH","horizontal","vertical","clearSelection","deleteSelectedElements","splice","getSelectedIndices","selectedIndices","push","someElementIsSelected","some","getSelectedAttribute","getAttribute","attributes","Array","from","Set","roundRect","context","radius","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","stroke","generator","rough","renderElement","rc","fillRect","shape","rectangle","globalAlpha","translate","draw","polygon","ellipse","options","shapes","line","fillText","text","baseline","actualBoundingBoxAscent","renderScene","canvas","sceneState","offsetX","offsetY","renderScrollbars","renderSelection","getContext","viewBackgroundColor","clearRect","selectedElements","el","lineDash","getLineDash","setLineDash","strokeRect","margin","values","scrollBars","devicePixelRatio","strokeStyle","scrollBar","saveFile","name","data","link","setAttribute","click","remove","restore","savedElements","savedState","JSON","parse","undefined","e","getElementAtPosition","hitElement","capitalizeString","str","charAt","toUpperCase","slice","isInputLike","target","HTMLElement","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","measureText","innerHTML","offsetWidth","offsetHeight","span","overflow","offsetTop","ButtonSelect","value","onChange","className","option","onClick","SHAPES","icon","viewBox","d","shapesShortcutKeys","findShapeByKey","SceneHistory","recording","stateHistory","redoStack","stringify","newEntry","this","entry","newElements","skipRecording","currentEntry","generateCurrentEntry","entryToRestore","pop","restoreEntry","Popover","children","onCloseRequest","onContextMenu","contextMenuNode","ContextMenu","idx","ContextMenuOption","label","action","getContextMenuNode","div","handleClose","unmountComponentAtNode","params","of","render","Panel","title","defaultCollapsed","hide","useState","collapsed","setCollapsed","PanelTools","activeTool","onToolChange","checked","PanelSelection","onBringForward","onBringToFront","onSendBackward","onSendToBack","TwitterPicker","lazy","ColorPicker","React","isActive","setActive","Suspense","fallback","colors","changedColor","hex","onPaste","clipboardData","getData","PanelColor","onColorChange","colorValue","EditableText","props","state","edit","setState","maxLength","handleEdit","onBlur","handleBlur","onKeyDown","autoFocus","Component","PanelExport","projectName","exportBackground","onProjectNameChange","onExportBackgroundChange","onSaveScene","onLoadScene","onExportAsPNG","PanelCanvas","onViewBackgroundColorChange","onClearCanvas","history","DEFAULT_PROJECT_NAME","date","Date","year","getFullYear","month","getMonth","day","getDate","hr","getHours","getMinutes","secs","getSeconds","getDateTime","copiedStyles","resetCursor","documentElement","cursor","addTextElement","metrics","lastCanvasWidth","lastCanvasHeight","lastMouseUp","viewportCoordsToSceneCoords","clientX","clientY","App","draggingElement","resizingElement","elementType","currentItemStrokeColor","currentItemBackgroundColor","currentItemFont","cursorX","cursorY","onResize","forceUpdate","getCurrentCursorPosition","event","step","shiftKey","altKey","code","includes","toLowerCase","redoOnce","undoOnce","metaKey","copyStyles","pasteStyles","clearCanvas","confirm","find","pastedElement","redrawTextBoundingBox","removeWheelEventListener","changeProperty","callback","changeOpacity","changeStrokeColor","changeBackgroundColor","copyToClipboard","clipboard","writeText","pasteFromClipboard","readText","then","addElementsFromPaste","handleWheel","deltaX","deltaY","paste","parsedElements","isArray","subCanvasX1","subCanvasX2","subCanvasY1","subCanvasY2","parsedElement","elementsCenterX","elementsCenterY","duplicate","localStorage","getItem","innerWidth","innerHeight","onCut","setData","onCopy","hasStroke","hasText","split","val","updateProjectName","exportPadding","alert","tempCanvas","toDataURL","exportAsPNG","serialized","version","source","location","origin","encodeURIComponent","saveAsJSON","input","reader","FileReader","accept","onchange","files","readAsText","Promise","resolve","onloadend","readyState","DONE","loadFromJSON","ref","passive","scale","onMouseDown","button","activeElement","blur","isOverHorizontalScrollBar","isOverVerticalScrollBar","isOverScrollBars","isDraggingElements","isResizingElements","resizeElement","duplicates","textX","textY","snappedToCenterPosition","getTextWysiwygSnappedToCenterPosition","elementCenterX","elementCenterY","wysiwygX","wysiwygY","lastX","lastY","onMouseMove","sign","selectionX1","selectionY1","selectionX2","selectionY2","setSelection","onMouseUp","onDoubleClick","elementAtPosition","indexOf","Boolean","buttons","elementClickedInside","getElementContainingPosition","setItem","isRecording","pushEntry","clearRedoStack","resumeRecording","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.87043d13.chunk.js","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n}\n\nexport function moveOneRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n  let isSorted = true;\n\n  // We go from right to left to avoid overriding the wrong elements\n  reversedIndicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index + 1, index);\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beggining\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beggining\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\nexport function moveAllRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n\n  // Copy the elements to move\n  const rightMostElements = reversedIndicesToMove.map(index => elements[index]);\n\n  indicesToMove = reversedIndicesToMove\n    // We go from left to right to avoid overriding elements.\n    .reverse()\n    // We last element index for the final marker\n    .concat([elements.length]);\n\n  indicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the left (i - 1) to the current one (index)\n    for (let pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  });\n\n  // The final step\n  rightMostElements.forEach((element, i) => {\n    elements[elements.length - i - 1] = element;\n  });\n}\n","// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316\nexport const LCG = (seed: number) => () =>\n  ((2 ** 31 - 1) & (seed = Math.imul(48271, seed))) / 2 ** 31;\n\nexport function randomSeed() {\n  return Math.floor(Math.random() * 2 ** 31);\n}\n\n// Unfortunately, roughjs doesn't support a seed attribute (https://github.com/pshihn/rough/issues/27).\n// We can achieve the same result by overriding the Math.random function with a\n// pseudo random generator that supports a random seed and swapping it back after.\nexport function withCustomMathRandom<T>(seed: number, cb: () => T): T {\n  const random = Math.random;\n  Math.random = LCG(seed);\n  const result = cb();\n  Math.random = random;\n  return result;\n}\n","import { randomSeed } from \"../random\";\nimport nanoid from \"nanoid\";\n\nexport function newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  fillStyle: string,\n  strokeWidth: number,\n  roughness: number,\n  opacity: number,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    id: nanoid(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    roughness,\n    opacity,\n    isSelected: false,\n    seed: randomSeed()\n  };\n  return element;\n}\n\nexport function duplicateElement(element: ReturnType<typeof newElement>) {\n  const copy = { ...element };\n  copy.id = nanoid();\n  copy.seed = randomSeed();\n  return copy;\n}\n","// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nexport function rotate(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number\n) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n","import { ExcalidrawElement } from \"./types\";\nimport { rotate } from \"../math\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nexport function getElementAbsoluteCoords(element: ExcalidrawElement) {\n  return [\n    element.width >= 0 ? element.x : element.x + element.width, // x1\n    element.height >= 0 ? element.y : element.y + element.height, // y1\n    element.width >= 0 ? element.x + element.width : element.x, // x2\n    element.height >= 0 ? element.y + element.height : element.y // y2\n  ];\n}\n\nexport function getDiamondPoints(element: ExcalidrawElement) {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\n\nexport function getArrowPoints(element: ExcalidrawElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n","import { ExcalidrawElement } from \"./types\";\nimport { SceneScroll } from \"../scene/types\";\n\ntype Sides = \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\";\n\nexport function handlerRectangles(\n  element: ExcalidrawElement,\n  { scrollX, scrollY }: SceneScroll\n) {\n  const elementX1 = element.x;\n  const elementX2 = element.x + element.width;\n  const elementY1 = element.y;\n  const elementY2 = element.y + element.height;\n\n  const margin = 4;\n  const minimumSize = 40;\n  const handlers = {} as { [T in Sides]: number[] };\n\n  const marginX = element.width < 0 ? 8 : -8;\n  const marginY = element.height < 0 ? 8 : -8;\n\n  if (Math.abs(elementX2 - elementX1) > minimumSize) {\n    handlers[\"n\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + scrollX - 4,\n      elementY1 - margin + scrollY + marginY,\n      8,\n      8\n    ];\n\n    handlers[\"s\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + scrollX - 4,\n      elementY2 - margin + scrollY - marginY,\n      8,\n      8\n    ];\n  }\n\n  if (Math.abs(elementY2 - elementY1) > minimumSize) {\n    handlers[\"w\"] = [\n      elementX1 - margin + scrollX + marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + scrollY - 4,\n      8,\n      8\n    ];\n\n    handlers[\"e\"] = [\n      elementX2 - margin + scrollX - marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + scrollY - 4,\n      8,\n      8\n    ];\n  }\n\n  handlers[\"nw\"] = [\n    elementX1 - margin + scrollX + marginX,\n    elementY1 - margin + scrollY + marginY,\n    8,\n    8\n  ]; // nw\n  handlers[\"ne\"] = [\n    elementX2 - margin + scrollX - marginX,\n    elementY1 - margin + scrollY + marginY,\n    8,\n    8\n  ]; // ne\n  handlers[\"sw\"] = [\n    elementX1 - margin + scrollX + marginX,\n    elementY2 - margin + scrollY - marginY,\n    8,\n    8\n  ]; // sw\n  handlers[\"se\"] = [\n    elementX2 - margin + scrollX - marginX,\n    elementY2 - margin + scrollY - marginY,\n    8,\n    8\n  ]; // se\n\n  if (element.type === \"arrow\") {\n    return {\n      nw: handlers.nw,\n      se: handlers.se\n    } as typeof handlers;\n  }\n\n  return handlers;\n}\n","import { distanceBetweenPointAndSegment } from \"../math\";\n\nimport { ExcalidrawElement } from \"./types\";\nimport {\n  getArrowPoints,\n  getDiamondPoints,\n  getElementAbsoluteCoords\n} from \"./bounds\";\n\nexport function hitTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number\n): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n\n    const [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY\n    ] = getDiamondPoints(element);\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n","import { ExcalidrawElement } from \"./types\";\n\nimport { handlerRectangles } from \"./handlerRectangles\";\nimport { SceneScroll } from \"../scene/types\";\n\ntype HandlerRectanglesRet = keyof ReturnType<typeof handlerRectangles>;\n\nexport function resizeTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n  { scrollX, scrollY }: SceneScroll\n): HandlerRectanglesRet | false {\n  if (!element.isSelected || element.type === \"text\") return false;\n\n  const handlers = handlerRectangles(element, { scrollX, scrollY });\n\n  const filter = Object.keys(handlers).filter(key => {\n    const handler = handlers[key as HandlerRectanglesRet]!;\n\n    return (\n      x + scrollX >= handler[0] &&\n      x + scrollX <= handler[0] + handler[2] &&\n      y + scrollY >= handler[1] &&\n      y + scrollY <= handler[1] + handler[3]\n    );\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as HandlerRectanglesRet;\n  }\n\n  return false;\n}\n\nexport function getElementWithResizeHandler(\n  elements: ExcalidrawElement[],\n  { x, y }: { x: number; y: number },\n  { scrollX, scrollY }: SceneScroll\n) {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const resizeHandle = resizeTest(element, x, y, {\n      scrollX,\n      scrollY\n    });\n    return resizeHandle ? { element, resizeHandle } : null;\n  }, null as { element: ExcalidrawElement; resizeHandle: ReturnType<typeof resizeTest> } | null);\n}\n","import { ExcalidrawElement, ExcalidrawTextElement } from \"./types\";\n\nexport function isTextElement(\n  element: ExcalidrawElement\n): element is ExcalidrawTextElement {\n  return element.type === \"text\";\n}\n","export const KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\nexport const META_KEY = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n  ? \"metaKey\"\n  : \"ctrlKey\";\n\nexport function isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n","import { KEYS } from \"../keys\";\n\ntype TextWysiwygParams = {\n  initText: string;\n  x: number;\n  y: number;\n  strokeColor: string;\n  font: string;\n  onSubmit: (text: string) => void;\n};\n\nexport function textWysiwyg({\n  initText,\n  x,\n  y,\n  strokeColor,\n  font,\n  onSubmit\n}: TextWysiwygParams) {\n  // Using contenteditable here as it has dynamic width.\n  // But this solution has an issue — it allows to paste\n  // multiline text, which is not currently supported\n  const editable = document.createElement(\"div\");\n  editable.contentEditable = \"plaintext-only\";\n  editable.tabIndex = 0;\n  editable.innerText = initText;\n  editable.dataset.type = \"wysiwyg\";\n\n  Object.assign(editable.style, {\n    color: strokeColor,\n    position: \"absolute\",\n    top: y + \"px\",\n    left: x + \"px\",\n    transform: \"translate(-50%, -50%)\",\n    textAlign: \"center\",\n    display: \"inline-block\",\n    font: font,\n    padding: \"4px\",\n    outline: \"transparent\",\n    whiteSpace: \"nowrap\"\n  });\n\n  editable.onkeydown = ev => {\n    if (ev.key === KEYS.ESCAPE) {\n      ev.preventDefault();\n      if (initText) {\n        editable.innerText = initText;\n        handleSubmit();\n        return;\n      }\n      cleanup();\n      return;\n    }\n    if (ev.key === KEYS.ENTER) {\n      ev.preventDefault();\n      handleSubmit();\n    }\n  };\n  editable.onblur = handleSubmit;\n\n  function stopEvent(ev: Event) {\n    ev.stopPropagation();\n  }\n\n  function handleSubmit() {\n    if (editable.innerText) {\n      onSubmit(editable.innerText);\n    }\n    cleanup();\n  }\n\n  function cleanup() {\n    editable.onblur = null;\n    editable.onkeydown = null;\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    document.body.removeChild(editable);\n  }\n\n  window.addEventListener(\"wheel\", stopEvent, true);\n  document.body.appendChild(editable);\n  editable.focus();\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(editable);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getElementAbsoluteCoords } from \"../element\";\n\nconst SCROLLBAR_MIN_SIZE = 15;\nconst SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport function getScrollBars(\n  elements: ExcalidrawElement[],\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  let minX = Infinity;\n  let maxX = 0;\n  let minY = Infinity;\n  let maxY = 0;\n\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  minX += scrollX;\n  maxX += scrollX;\n  minY += scrollY;\n  maxY += scrollY;\n  const leftOverflow = Math.max(-minX, 0);\n  const rightOverflow = Math.max(-(canvasWidth - maxX), 0);\n  const topOverflow = Math.max(-minY, 0);\n  const bottomOverflow = Math.max(-(canvasHeight - maxY), 0);\n\n  // horizontal scrollbar\n  let horizontalScrollBar = null;\n  if (leftOverflow || rightOverflow) {\n    horizontalScrollBar = {\n      x: Math.min(\n        leftOverflow + SCROLLBAR_MARGIN,\n        canvasWidth - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      y: canvasHeight - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      width: Math.max(\n        canvasWidth - rightOverflow - leftOverflow - SCROLLBAR_MARGIN * 2,\n        SCROLLBAR_MIN_SIZE\n      ),\n      height: SCROLLBAR_WIDTH\n    };\n  }\n\n  // vertical scrollbar\n  let verticalScrollBar = null;\n  if (topOverflow || bottomOverflow) {\n    verticalScrollBar = {\n      x: canvasWidth - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      y: Math.min(\n        topOverflow + SCROLLBAR_MARGIN,\n        canvasHeight - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      width: SCROLLBAR_WIDTH,\n      height: Math.max(\n        canvasHeight - bottomOverflow - topOverflow - SCROLLBAR_WIDTH * 2,\n        SCROLLBAR_MIN_SIZE\n      )\n    };\n  }\n\n  return {\n    horizontal: horizontalScrollBar,\n    vertical: verticalScrollBar\n  };\n}\n\nexport function isOverScrollBars(\n  elements: ExcalidrawElement[],\n  x: number,\n  y: number,\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  const scrollBars = getScrollBars(\n    elements,\n    canvasWidth,\n    canvasHeight,\n    scrollX,\n    scrollY\n  );\n\n  const [isOverHorizontalScrollBar, isOverVerticalScrollBar] = [\n    scrollBars.horizontal,\n    scrollBars.vertical\n  ].map(\n    scrollBar =>\n      scrollBar &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n  );\n\n  return {\n    isOverHorizontalScrollBar,\n    isOverVerticalScrollBar\n  };\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport function setSelection(\n  elements: ExcalidrawElement[],\n  selection: ExcalidrawElement\n) {\n  const [\n    selectionX1,\n    selectionY1,\n    selectionX2,\n    selectionY2\n  ] = getElementAbsoluteCoords(selection);\n  elements.forEach(element => {\n    const [\n      elementX1,\n      elementY1,\n      elementX2,\n      elementY2\n    ] = getElementAbsoluteCoords(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nexport function clearSelection(elements: ExcalidrawElement[]) {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nexport function deleteSelectedElements(elements: ExcalidrawElement[]) {\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\nexport function getSelectedIndices(elements: ExcalidrawElement[]) {\n  const selectedIndices: number[] = [];\n  elements.forEach((element, index) => {\n    if (element.isSelected) {\n      selectedIndices.push(index);\n    }\n  });\n  return selectedIndices;\n}\n\nexport const someElementIsSelected = (elements: ExcalidrawElement[]) =>\n  elements.some(element => element.isSelected);\n\nexport function getSelectedAttribute<T>(\n  elements: ExcalidrawElement[],\n  getAttribute: (element: ExcalidrawElement) => T\n): T | null {\n  const attributes = Array.from(\n    new Set(\n      elements\n        .filter(element => element.isSelected)\n        .map(element => getAttribute(element))\n    )\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n}\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport function roundRect(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number\n) {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n}\n","import rough from \"roughjs/bin/wrappers/rough\";\n\nimport { withCustomMathRandom } from \"../random\";\n\nimport { ExcalidrawElement } from \"../element/types\";\nimport { isTextElement } from \"../element/typeChecks\";\nimport { getDiamondPoints, getArrowPoints } from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { SceneState } from \"../scene/types\";\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nconst generator = rough.generator(null, null as any);\n\nexport function renderElement(\n  element: ExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  { scrollX, scrollY }: SceneState\n) {\n  if (element.type === \"selection\") {\n    const fillStyle = context.fillStyle;\n    context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n    context.fillRect(\n      element.x + scrollX,\n      element.y + scrollY,\n      element.width,\n      element.height\n    );\n    context.fillStyle = fillStyle;\n  } else if (element.type === \"rectangle\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      return generator.rectangle(0, 0, element.width, element.height, {\n        stroke: element.strokeColor,\n        fill: element.backgroundColor,\n        fillStyle: element.fillStyle,\n        strokeWidth: element.strokeWidth,\n        roughness: element.roughness\n      });\n    });\n\n    context.globalAlpha = element.opacity / 100;\n    context.translate(element.x + scrollX, element.y + scrollY);\n    rc.draw(shape);\n    context.translate(-element.x - scrollX, -element.y - scrollY);\n    context.globalAlpha = 1;\n  } else if (element.type === \"diamond\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      const [\n        topX,\n        topY,\n        rightX,\n        rightY,\n        bottomX,\n        bottomY,\n        leftX,\n        leftY\n      ] = getDiamondPoints(element);\n      return generator.polygon(\n        [\n          [topX, topY],\n          [rightX, rightY],\n          [bottomX, bottomY],\n          [leftX, leftY]\n        ],\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      );\n    });\n    context.globalAlpha = element.opacity / 100;\n    context.translate(element.x + scrollX, element.y + scrollY);\n    rc.draw(shape);\n    context.translate(-element.x - scrollX, -element.y - scrollY);\n    context.globalAlpha = 1;\n  } else if (element.type === \"ellipse\") {\n    const shape = withCustomMathRandom(element.seed, () =>\n      generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      )\n    );\n\n    context.globalAlpha = element.opacity / 100;\n    context.translate(element.x + scrollX, element.y + scrollY);\n    rc.draw(shape);\n    context.translate(-element.x - scrollX, -element.y - scrollY);\n    context.globalAlpha = 1;\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const options = {\n      stroke: element.strokeColor,\n      strokeWidth: element.strokeWidth,\n      roughness: element.roughness\n    };\n\n    const shapes = withCustomMathRandom(element.seed, () => [\n      //    \\\n      generator.line(x3, y3, x2, y2, options),\n      // -----\n      generator.line(x1, y1, x2, y2, options),\n      //    /\n      generator.line(x4, y4, x2, y2, options)\n    ]);\n\n    context.globalAlpha = element.opacity / 100;\n    context.translate(element.x + scrollX, element.y + scrollY);\n    shapes.forEach(shape => rc.draw(shape));\n    context.translate(-element.x - scrollX, -element.y - scrollY);\n    context.globalAlpha = 1;\n    return;\n  } else if (isTextElement(element)) {\n    context.globalAlpha = element.opacity / 100;\n    const font = context.font;\n    context.font = element.font;\n    const fillStyle = context.fillStyle;\n    context.fillStyle = element.strokeColor;\n    context.fillText(\n      element.text,\n      element.x + scrollX,\n      element.y +\n        scrollY +\n        (element.baseline || element.actualBoundingBoxAscent || 0)\n    );\n    context.fillStyle = fillStyle;\n    context.font = font;\n    context.globalAlpha = 1;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getElementAbsoluteCoords, handlerRectangles } from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH\n} from \"../scene/scrollbars\";\n\nimport { renderElement } from \"./renderElement\";\n\nexport function renderScene(\n  elements: ExcalidrawElement[],\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    offsetX,\n    offsetY,\n    renderScrollbars = true,\n    renderSelection = true\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n  } = {}\n) {\n  if (!canvas) return;\n  const context = canvas.getContext(\"2d\")!;\n\n  const fillStyle = context.fillStyle;\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  } else {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  sceneState = {\n    ...sceneState,\n    scrollX: typeof offsetX === \"number\" ? offsetX : sceneState.scrollX,\n    scrollY: typeof offsetY === \"number\" ? offsetY : sceneState.scrollY\n  };\n\n  elements.forEach(element => {\n    renderElement(element, rc, context, sceneState);\n  });\n\n  if (renderSelection) {\n    const selectedElements = elements.filter(el => el.isSelected);\n\n    selectedElements.forEach(element => {\n      const margin = 4;\n\n      const [\n        elementX1,\n        elementY1,\n        elementX2,\n        elementY2\n      ] = getElementAbsoluteCoords(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin + sceneState.scrollX,\n        elementY1 - margin + sceneState.scrollY,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n    });\n\n    if (selectedElements.length === 1 && selectedElements[0].type !== \"text\") {\n      const handlers = handlerRectangles(selectedElements[0], sceneState);\n      Object.values(handlers).forEach(handler => {\n        context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n      });\n    }\n  }\n\n  if (renderScrollbars) {\n    const scrollBars = getScrollBars(\n      elements,\n      context.canvas.width / window.devicePixelRatio,\n      context.canvas.height / window.devicePixelRatio,\n      sceneState.scrollX,\n      sceneState.scrollY\n    );\n\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar)\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2\n        );\n    });\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n  }\n}\n","import rough from \"roughjs/bin/wrappers/rough\";\n\nimport { ExcalidrawElement } from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nimport { renderScene } from \"../renderer\";\nimport { AppState } from \"../types\";\nimport nanoid from \"nanoid\";\n\nconst LOCAL_STORAGE_KEY = \"excalidraw\";\nconst LOCAL_STORAGE_KEY_STATE = \"excalidraw-state\";\n\nfunction saveFile(name: string, data: string) {\n  // create a temporary <a> elem which we'll use to download the image\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"download\", name);\n  link.setAttribute(\"href\", data);\n  link.click();\n\n  // clean up\n  link.remove();\n}\n\nexport function saveAsJSON(elements: ExcalidrawElement[], name: string) {\n  const serialized = JSON.stringify({\n    version: 1,\n    source: window.location.origin,\n    elements\n  });\n\n  saveFile(\n    `${name}.json`,\n    \"data:text/plain;charset=utf-8,\" + encodeURIComponent(serialized)\n  );\n}\n\nexport function loadFromJSON(elements: ExcalidrawElement[]) {\n  const input = document.createElement(\"input\");\n  const reader = new FileReader();\n  input.type = \"file\";\n  input.accept = \".json\";\n\n  input.onchange = () => {\n    if (!input.files!.length) {\n      alert(\"A file was not selected.\");\n      return;\n    }\n\n    reader.readAsText(input.files![0], \"utf8\");\n  };\n\n  input.click();\n\n  return new Promise(resolve => {\n    reader.onloadend = () => {\n      if (reader.readyState === FileReader.DONE) {\n        const data = JSON.parse(reader.result as string);\n        restore(elements, data.elements, null);\n        resolve();\n      }\n    };\n  });\n}\n\nexport function exportAsPNG(\n  elements: ExcalidrawElement[],\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    scrollX: number;\n    scrollY: number;\n    name: string;\n  }\n) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n  // calculate smallest area to fit the contents in\n\n  let subCanvasX1 = Infinity;\n  let subCanvasX2 = 0;\n  let subCanvasY1 = Infinity;\n  let subCanvasY2 = 0;\n\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    subCanvasX1 = Math.min(subCanvasX1, x1);\n    subCanvasY1 = Math.min(subCanvasY1, y1);\n    subCanvasX2 = Math.max(subCanvasX2, x2);\n    subCanvasY2 = Math.max(subCanvasY2, y2);\n  });\n\n  function distance(x: number, y: number) {\n    return Math.abs(x > y ? x - y : y - x);\n  }\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  tempCanvas.width = distance(subCanvasX1, subCanvasX2) + exportPadding * 2;\n  tempCanvas.height = distance(subCanvasY1, subCanvasY2) + exportPadding * 2;\n\n  renderScene(\n    elements,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: 0,\n      scrollY: 0\n    },\n    {\n      offsetX: -subCanvasX1 + exportPadding,\n      offsetY: -subCanvasY1 + exportPadding,\n      renderScrollbars: false,\n      renderSelection: false\n    }\n  );\n\n  saveFile(`${name}.png`, tempCanvas.toDataURL(\"image/png\"));\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) tempCanvas.remove();\n}\n\nfunction restore(\n  elements: ExcalidrawElement[],\n  savedElements: string | ExcalidrawElement[] | null,\n  savedState: string | null\n) {\n  try {\n    if (savedElements) {\n      elements.splice(\n        0,\n        elements.length,\n        ...(typeof savedElements === \"string\"\n          ? JSON.parse(savedElements)\n          : savedElements)\n      );\n      elements.forEach((element: ExcalidrawElement) => {\n        element.id = element.id || nanoid();\n        element.fillStyle = element.fillStyle || \"hachure\";\n        element.strokeWidth = element.strokeWidth || 1;\n        element.roughness = element.roughness || 1;\n        element.opacity =\n          element.opacity === null || element.opacity === undefined\n            ? 100\n            : element.opacity;\n      });\n    }\n\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (e) {\n    elements.splice(0, elements.length);\n    return null;\n  }\n}\n\nexport function restoreFromLocalStorage(elements: ExcalidrawElement[]) {\n  const savedElements = localStorage.getItem(LOCAL_STORAGE_KEY);\n  const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_STATE);\n\n  return restore(elements, savedElements, savedState);\n}\n\nexport function saveToLocalStorage(\n  elements: ExcalidrawElement[],\n  state: AppState\n) {\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(elements));\n  localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(state));\n}\n","import { ExcalidrawElement } from \"../element/types\";\nimport { hitTest } from \"../element/collision\";\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (elements: ExcalidrawElement[]) =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\")\n  );\n\nexport const hasStroke = (elements: ExcalidrawElement[]) =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\" ||\n        element.type === \"arrow\")\n  );\n\nexport const hasText = (elements: ExcalidrawElement[]) =>\n  elements.some(element => element.isSelected && element.type === \"text\");\n\nexport function getElementAtPosition(\n  elements: ExcalidrawElement[],\n  x: number,\n  y: number\n) {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (hitTest(elements[i], x, y)) {\n      hitElement = elements[i];\n      break;\n    }\n  }\n\n  return hitElement;\n}\n\nexport function getElementContainingPosition(\n  elements: ExcalidrawElement[],\n  x: number,\n  y: number\n) {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let i = elements.length - 1; i >= 0; --i) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[i]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[i];\n      break;\n    }\n  }\n  return hitElement;\n}\n","export function getDateTime() {\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const hr = date.getHours();\n  const min = date.getMinutes();\n  const secs = date.getSeconds();\n\n  return `${year}${month}${day}${hr}${min}${secs}`;\n}\n\nexport function capitalizeString(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function isInputLike(\n  target: Element | EventTarget | null\n): target is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\n  return (\n    (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n    target instanceof HTMLInputElement ||\n    target instanceof HTMLTextAreaElement ||\n    target instanceof HTMLSelectElement\n  );\n}\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport function measureText(text: string, font: string) {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"nowrap\";\n  line.style.font = font;\n  body.appendChild(line);\n  // Now we can measure width and height of the letter\n  line.innerHTML = text;\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n}\n","import React from \"react\";\n\nexport function ButtonSelect<T>({\n  options,\n  value,\n  onChange\n}: {\n  options: { value: T; text: string }[];\n  value: T | null;\n  onChange: (value: T) => void;\n}) {\n  return (\n    <div className=\"buttonList\">\n      {options.map(option => (\n        <button\n          key={option.text}\n          onClick={() => onChange(option.value)}\n          className={value === option.value ? \"active\" : \"\"}\n        >\n          {option.text}\n        </button>\n      ))}\n    </div>\n  );\n}\n","import React from \"react\";\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nexport const SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\"\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\"\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\"\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\"\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\"\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\"\n  }\n];\n\nexport const shapesShortcutKeys = SHAPES.map(shape => shape.value[0]);\n\nexport function findShapeByKey(key: string) {\n  const defaultElement = \"selection\";\n  return SHAPES.reduce((element, shape) => {\n    if (shape.value[0] !== key) return element;\n\n    return shape.value;\n  }, defaultElement);\n}\n","import { ExcalidrawElement } from \"./element/types\";\n\nclass SceneHistory {\n  private recording: boolean = true;\n  private stateHistory: string[] = [];\n  private redoStack: string[] = [];\n\n  generateCurrentEntry(elements: ExcalidrawElement[]) {\n    return JSON.stringify(\n      elements.map(element => ({ ...element, isSelected: false }))\n    );\n  }\n\n  pushEntry(newEntry: string) {\n    if (\n      this.stateHistory.length > 0 &&\n      this.stateHistory[this.stateHistory.length - 1] === newEntry\n    ) {\n      // If the last entry is the same as this one, ignore it\n      return;\n    }\n    this.stateHistory.push(newEntry);\n  }\n\n  restoreEntry(elements: ExcalidrawElement[], entry: string) {\n    const newElements = JSON.parse(entry);\n    elements.splice(0, elements.length);\n    newElements.forEach((newElement: ExcalidrawElement) => {\n      elements.push(newElement);\n    });\n    // When restoring, we shouldn't add an history entry otherwise we'll be stuck with it and can't go back\n    this.skipRecording();\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(elements: ExcalidrawElement[]) {\n    const currentEntry = this.generateCurrentEntry(elements);\n    const entryToRestore = this.redoStack.pop();\n    if (entryToRestore !== undefined) {\n      this.restoreEntry(elements, entryToRestore);\n      this.stateHistory.push(currentEntry);\n    }\n  }\n\n  undoOnce(elements: ExcalidrawElement[]) {\n    const currentEntry = this.generateCurrentEntry(elements);\n    let entryToRestore = this.stateHistory.pop();\n\n    // If nothing was changed since last, take the previous one\n    if (currentEntry === entryToRestore) {\n      entryToRestore = this.stateHistory.pop();\n    }\n    if (entryToRestore !== undefined) {\n      this.restoreEntry(elements, entryToRestore);\n      this.redoStack.push(currentEntry);\n    }\n  }\n\n  isRecording() {\n    return this.recording;\n  }\n\n  skipRecording() {\n    this.recording = false;\n  }\n\n  resumeRecording() {\n    this.recording = true;\n  }\n}\n\nexport const createHistory: () => { history: SceneHistory } = () => {\n  const history = new SceneHistory();\n  return { history };\n};\n","import React from \"react\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(): void;\n};\n\nexport function Popover({ children, left, onCloseRequest, top }: Props) {\n  return (\n    <div className=\"popover\" style={{ top: top, left: left }}>\n      <div\n        className=\"cover\"\n        onClick={onCloseRequest}\n        onContextMenu={e => {\n          e.preventDefault();\n          if (onCloseRequest) onCloseRequest();\n        }}\n      />\n      {children}\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\n\nimport \"./ContextMenu.css\";\n\ntype ContextMenuOption = {\n  label: string;\n  action(): void;\n};\n\ntype Props = {\n  options: ContextMenuOption[];\n  onCloseRequest?(): void;\n  top: number;\n  left: number;\n};\n\nfunction ContextMenu({ options, onCloseRequest, top, left }: Props) {\n  return (\n    <Popover onCloseRequest={onCloseRequest} top={top} left={left}>\n      <ul className=\"context-menu\" onContextMenu={e => e.preventDefault()}>\n        {options.map((option, idx) => (\n          <li\n            key={idx}\n            className=\"context-menu__option\"\n            onClick={onCloseRequest}\n          >\n            <ContextMenuOption {...option} />\n          </li>\n        ))}\n      </ul>\n    </Popover>\n  );\n}\n\nfunction ContextMenuOption({ label, action }: ContextMenuOption) {\n  return (\n    <button className=\"context-menu-option\" onClick={action}>\n      {label}\n    </button>\n  );\n}\n\nlet contextMenuNode: HTMLDivElement;\nfunction getContextMenuNode(): HTMLDivElement {\n  if (contextMenuNode) {\n    return contextMenuNode;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  return (contextMenuNode = div);\n}\n\ntype ContextMenuParams = {\n  options: (ContextMenuOption | false | null | undefined)[];\n  top: number;\n  left: number;\n};\n\nfunction handleClose() {\n  unmountComponentAtNode(getContextMenuNode());\n}\n\nexport default {\n  push(params: ContextMenuParams) {\n    const options = Array.of<ContextMenuOption>();\n    params.options.forEach(option => {\n      if (option) {\n        options.push(option);\n      }\n    });\n    if (options.length) {\n      render(\n        <ContextMenu\n          top={params.top}\n          left={params.left}\n          options={options}\n          onCloseRequest={handleClose}\n        />,\n        getContextMenuNode()\n      );\n    }\n  }\n};\n","import React, { useState } from \"react\";\n\ninterface PanelProps {\n  title: string;\n  defaultCollapsed?: boolean;\n  hide?: boolean;\n}\n\nexport const Panel: React.FC<PanelProps> = ({\n  title,\n  children,\n  defaultCollapsed = false,\n  hide = false\n}) => {\n  const [collapsed, setCollapsed] = useState(defaultCollapsed);\n\n  if (hide) return null;\n\n  return (\n    <div className=\"panel\">\n      <h4>{title}</h4>\n      <button\n        className=\"btn-panel-collapse\"\n        type=\"button\"\n        onClick={e => {\n          e.preventDefault();\n          setCollapsed(collapsed => !collapsed);\n        }}\n      >\n        {\n          <span\n            className={`btn-panel-collapse-icon ${\n              collapsed ? \"btn-panel-collapse-icon-closed\" : \"\"\n            }`}\n          >\n            ▼\n          </span>\n        }\n      </button>\n      {!collapsed && <div className=\"panelColumn\">{children}</div>}\n    </div>\n  );\n};\n","import React from \"react\";\n\nimport { SHAPES } from \"../../shapes\";\nimport { capitalizeString } from \"../../utils\";\nimport { Panel } from \"../Panel\";\n\ninterface PanelToolsProps {\n  activeTool: string;\n  onToolChange: (value: string) => void;\n}\n\nexport const PanelTools: React.FC<PanelToolsProps> = ({\n  activeTool,\n  onToolChange\n}) => {\n  return (\n    <Panel title=\"Shapes\">\n      <div className=\"panelTools\">\n        {SHAPES.map(({ value, icon }) => (\n          <label\n            key={value}\n            className=\"tool\"\n            title={`${capitalizeString(value)} - ${capitalizeString(value)[0]}`}\n          >\n            <input\n              type=\"radio\"\n              checked={activeTool === value}\n              onChange={() => {\n                onToolChange(value);\n              }}\n            />\n            <div className=\"toolIcon\">{icon}</div>\n          </label>\n        ))}\n      </div>\n    </Panel>\n  );\n};\n","import React from \"react\";\n\ninterface PanelSelectionProps {\n  onBringForward: React.MouseEventHandler;\n  onBringToFront: React.MouseEventHandler;\n  onSendBackward: React.MouseEventHandler;\n  onSendToBack: React.MouseEventHandler;\n}\n\nexport const PanelSelection: React.FC<PanelSelectionProps> = ({\n  onBringForward,\n  onBringToFront,\n  onSendBackward,\n  onSendToBack\n}) => {\n  return (\n    <div>\n      <div className=\"buttonList\">\n        <button type=\"button\" onClick={onBringForward}>\n          Bring forward\n        </button>\n        <button type=\"button\" onClick={onBringToFront}>\n          Bring to front\n        </button>\n        <button type=\"button\" onClick={onSendBackward}>\n          Send backward\n        </button>\n        <button type=\"button\" onClick={onSendToBack}>\n          Send to back\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React, { lazy } from \"react\";\nimport { Popover } from \"./Popover\";\n\nconst TwitterPicker = lazy(() =>\n  import(\n    /* webpackPrefetch: true */ \"react-color/lib/components/twitter/Twitter\"\n  )\n);\n\nexport function ColorPicker({\n  color,\n  onChange\n}: {\n  color: string | null;\n  onChange: (color: string) => void;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  return (\n    <div>\n      <button\n        className=\"swatch\"\n        style={color ? { backgroundColor: color } : undefined}\n        onClick={() => setActive(!isActive)}\n      />\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <Popover onCloseRequest={() => setActive(false)}>\n            <TwitterPicker\n              colors={[\n                \"#000000\",\n                \"#ABB8C3\",\n                \"#FFFFFF\",\n                \"#FF6900\",\n                \"#FCB900\",\n                \"#00D084\",\n                \"#8ED1FC\",\n                \"#0693E3\",\n                \"#EB144C\",\n                \"#F78DA7\",\n                \"#9900EF\"\n              ]}\n              width=\"205px\"\n              color={color || undefined}\n              onChange={changedColor => {\n                onChange(changedColor.hex);\n              }}\n            />\n          </Popover>\n        ) : null}\n      </React.Suspense>\n      <input\n        type=\"text\"\n        className=\"swatch-input\"\n        value={color || \"\"}\n        onPaste={e => onChange(e.clipboardData.getData(\"text\"))}\n        onChange={e => onChange(e.target.value)}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport { ColorPicker } from \"../ColorPicker\";\n\ninterface PanelColorProps {\n  title: string;\n  colorValue: string | null;\n  onColorChange: (value: string) => void;\n}\n\nexport const PanelColor: React.FC<PanelColorProps> = ({\n  title,\n  onColorChange,\n  colorValue\n}) => {\n  return (\n    <>\n      <h5>{title}</h5>\n      <ColorPicker\n        color={colorValue}\n        onChange={color => onColorChange(color)}\n      />\n    </>\n  );\n};\n","import React, { Fragment, Component } from \"react\";\n\ntype InputState = {\n  value: string;\n  edit: boolean;\n};\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport class EditableText extends Component<Props, InputState> {\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      value: props.value,\n      edit: false\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(props: Props) {\n    this.setState({ value: props.value });\n  }\n\n  private handleEdit(e: React.ChangeEvent<HTMLInputElement>) {\n    this.setState({ value: e.target.value });\n  }\n\n  private handleBlur() {\n    const { value } = this.state;\n\n    if (!value) {\n      this.setState({ value: this.props.value, edit: false });\n      return;\n    }\n    this.props.onChange(value);\n    this.setState({ edit: false });\n  }\n\n  public render() {\n    const { value, edit } = this.state;\n\n    return (\n      <Fragment>\n        {edit ? (\n          <input\n            className=\"project-name-input\"\n            name=\"name\"\n            maxLength={25}\n            value={value}\n            onChange={e => this.handleEdit(e)}\n            onBlur={() => this.handleBlur()}\n            onKeyDown={e => {\n              if (e.key === \"Enter\") {\n                this.handleBlur();\n              }\n            }}\n            autoFocus\n          />\n        ) : (\n          <span\n            onClick={() => this.setState({ edit: true })}\n            className=\"project-name\"\n          >\n            {value}\n          </span>\n        )}\n      </Fragment>\n    );\n  }\n}\n","import React from \"react\";\nimport { EditableText } from \"../EditableText\";\nimport { Panel } from \"../Panel\";\n\ninterface PanelExportProps {\n  projectName: string;\n  onProjectNameChange: (name: string) => void;\n  onExportAsPNG: React.MouseEventHandler;\n  exportBackground: boolean;\n  onExportBackgroundChange: (val: boolean) => void;\n  onSaveScene: React.MouseEventHandler;\n  onLoadScene: React.MouseEventHandler;\n}\n\nexport const PanelExport: React.FC<PanelExportProps> = ({\n  projectName,\n  exportBackground,\n  onProjectNameChange,\n  onExportBackgroundChange,\n  onSaveScene,\n  onLoadScene,\n  onExportAsPNG\n}) => {\n  return (\n    <Panel title=\"Export\">\n      <div className=\"panelColumn\">\n        <h5>Name</h5>\n        {projectName && (\n          <EditableText\n            value={projectName}\n            onChange={(name: string) => onProjectNameChange(name)}\n          />\n        )}\n        <h5>Image</h5>\n        <button onClick={onExportAsPNG}>Export to png</button>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={exportBackground}\n            onChange={e => {\n              onExportBackgroundChange(e.target.checked);\n            }}\n          />\n          background\n        </label>\n        <h5>Scene</h5>\n        <button onClick={onSaveScene}>Save as...</button>\n        <button onClick={onLoadScene}>Load file...</button>\n      </div>\n    </Panel>\n  );\n};\n","import React from \"react\";\n\nimport { ColorPicker } from \"../ColorPicker\";\nimport { Panel } from \"../Panel\";\n\ninterface PanelCanvasProps {\n  viewBackgroundColor: string;\n  onViewBackgroundColorChange: (val: string) => void;\n  onClearCanvas: React.MouseEventHandler;\n}\n\nexport const PanelCanvas: React.FC<PanelCanvasProps> = ({\n  viewBackgroundColor,\n  onViewBackgroundColorChange,\n  onClearCanvas\n}) => {\n  return (\n    <Panel title=\"Canvas\">\n      <h5>Canvas Background Color</h5>\n      <ColorPicker\n        color={viewBackgroundColor}\n        onChange={color => onViewBackgroundColorChange(color)}\n      />\n      <button\n        type=\"button\"\n        onClick={onClearCanvas}\n        title=\"Clear the canvas & reset background color\"\n      >\n        Clear canvas\n      </button>\n    </Panel>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport rough from \"roughjs/bin/wrappers/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport { moveOneLeft, moveAllLeft, moveOneRight, moveAllRight } from \"./zindex\";\nimport {\n  newElement,\n  duplicateElement,\n  resizeTest,\n  isTextElement,\n  textWysiwyg,\n  getElementAbsoluteCoords\n} from \"./element\";\nimport {\n  clearSelection,\n  getSelectedIndices,\n  deleteSelectedElements,\n  setSelection,\n  isOverScrollBars,\n  someElementIsSelected,\n  getSelectedAttribute,\n  loadFromJSON,\n  saveAsJSON,\n  exportAsPNG,\n  restoreFromLocalStorage,\n  saveToLocalStorage,\n  hasBackground,\n  hasStroke,\n  getElementAtPosition,\n  createScene,\n  getElementContainingPosition,\n  hasText\n} from \"./scene\";\n\nimport { renderScene } from \"./renderer\";\nimport { AppState } from \"./types\";\nimport { ExcalidrawElement, ExcalidrawTextElement } from \"./element/types\";\n\nimport { getDateTime, isInputLike, measureText } from \"./utils\";\nimport { KEYS, META_KEY, isArrowKey } from \"./keys\";\n\nimport { ButtonSelect } from \"./components/ButtonSelect\";\nimport { findShapeByKey, shapesShortcutKeys } from \"./shapes\";\nimport { createHistory } from \"./history\";\n\nimport ContextMenu from \"./components/ContextMenu\";\nimport { PanelTools } from \"./components/panels/PanelTools\";\nimport { PanelSelection } from \"./components/panels/PanelSelection\";\nimport { PanelColor } from \"./components/panels/PanelColor\";\nimport { PanelExport } from \"./components/panels/PanelExport\";\nimport { PanelCanvas } from \"./components/panels/PanelCanvas\";\nimport { Panel } from \"./components/Panel\";\n\nimport \"./styles.scss\";\nimport { getElementWithResizeHandler } from \"./element/resizeTest\";\n\nconst { elements } = createScene();\nconst { history } = createHistory();\nconst DEFAULT_PROJECT_NAME = `excalidraw-${getDateTime()}`;\n\nconst CANVAS_WINDOW_OFFSET_LEFT = 250;\nconst CANVAS_WINDOW_OFFSET_TOP = 0;\n\nlet copiedStyles: string = \"{}\";\n\nfunction resetCursor() {\n  document.documentElement.style.cursor = \"\";\n}\n\nfunction addTextElement(\n  element: ExcalidrawTextElement,\n  text: string,\n  font: string\n) {\n  resetCursor();\n  if (text === null || text === \"\") {\n    return false;\n  }\n\n  const metrics = measureText(text, font);\n  element.text = text;\n  element.font = font;\n  // Center the text\n  element.x -= metrics.width / 2;\n  element.y -= metrics.height / 2;\n  element.width = metrics.width;\n  element.height = metrics.height;\n  element.baseline = metrics.baseline;\n\n  return true;\n}\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\nconst TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\n\nlet lastCanvasWidth = -1;\nlet lastCanvasHeight = -1;\n\nlet lastMouseUp: ((e: any) => void) | null = null;\n\nexport function viewportCoordsToSceneCoords(\n  { clientX, clientY }: { clientX: number; clientY: number },\n  { scrollX, scrollY }: { scrollX: number; scrollY: number }\n) {\n  const x = clientX - CANVAS_WINDOW_OFFSET_LEFT - scrollX;\n  const y = clientY - CANVAS_WINDOW_OFFSET_TOP - scrollY;\n  return { x, y };\n}\n\nexport class App extends React.Component<{}, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    document.addEventListener(\"mousemove\", this.getCurrentCursorPosition);\n    window.addEventListener(\"resize\", this.onResize, false);\n\n    const savedState = restoreFromLocalStorage(elements);\n    if (savedState) {\n      this.setState(savedState);\n    }\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    document.removeEventListener(\n      \"mousemove\",\n      this.getCurrentCursorPosition,\n      false\n    );\n    window.removeEventListener(\"resize\", this.onResize, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    resizingElement: null,\n    elementType: \"selection\",\n    exportBackground: true,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    currentItemFont: \"20px Virgil\",\n    viewBackgroundColor: \"#ffffff\",\n    scrollX: 0,\n    scrollY: 0,\n    cursorX: 0,\n    cursorY: 0,\n    name: DEFAULT_PROJECT_NAME\n  };\n\n  private onResize = () => {\n    this.forceUpdate();\n  };\n\n  private getCurrentCursorPosition = (e: MouseEvent) => {\n    this.setState({ cursorX: e.x, cursorY: e.y });\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (isInputLike(event.target)) return;\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection(elements);\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      this.deleteSelectedElements();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send backward: Cmd-Shift-Alt-B\n    } else if (\n      event[META_KEY] &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyB\"\n    ) {\n      this.moveOneLeft();\n      event.preventDefault();\n\n      // Send to back: Cmd-Shift-B\n    } else if (event[META_KEY] && event.shiftKey && event.code === \"KeyB\") {\n      this.moveAllLeft();\n      event.preventDefault();\n\n      // Bring forward: Cmd-Shift-Alt-F\n    } else if (\n      event[META_KEY] &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyF\"\n    ) {\n      this.moveOneRight();\n      event.preventDefault();\n\n      // Bring to front: Cmd-Shift-F\n    } else if (event[META_KEY] && event.shiftKey && event.code === \"KeyF\") {\n      this.moveAllRight();\n      event.preventDefault();\n      // Select all: Cmd-A\n    } else if (event[META_KEY] && event.code === \"KeyA\") {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n      this.setState({ elementType: findShapeByKey(event.key) });\n    } else if (event[META_KEY] && event.code === \"KeyZ\") {\n      if (event.shiftKey) {\n        // Redo action\n        history.redoOnce(elements);\n      } else {\n        // undo action\n        history.undoOnce(elements);\n      }\n      this.forceUpdate();\n      event.preventDefault();\n      // Copy Styles: Cmd-Shift-C\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyC\") {\n      this.copyStyles();\n      // Paste Styles: Cmd-Shift-V\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyV\") {\n      this.pasteStyles();\n      event.preventDefault();\n    }\n  };\n\n  private deleteSelectedElements = () => {\n    deleteSelectedElements(elements);\n    this.forceUpdate();\n  };\n\n  private clearCanvas = () => {\n    if (window.confirm(\"This will clear the whole canvas. Are you sure?\")) {\n      elements.splice(0, elements.length);\n      this.setState({\n        viewBackgroundColor: \"#ffffff\",\n        scrollX: 0,\n        scrollY: 0\n      });\n      this.forceUpdate();\n    }\n  };\n\n  private copyStyles = () => {\n    const element = elements.find(el => el.isSelected);\n    if (element) {\n      copiedStyles = JSON.stringify(element);\n    }\n  };\n\n  private pasteStyles = () => {\n    const pastedElement = JSON.parse(copiedStyles);\n    elements.forEach(element => {\n      if (element.isSelected) {\n        element.backgroundColor = pastedElement?.backgroundColor;\n        element.strokeWidth = pastedElement?.strokeWidth;\n        element.strokeColor = pastedElement?.strokeColor;\n        element.fillStyle = pastedElement?.fillStyle;\n        element.opacity = pastedElement?.opacity;\n        element.roughness = pastedElement?.roughness;\n        if (isTextElement(element)) {\n          element.font = pastedElement?.font;\n          this.redrawTextBoundingBox(element);\n        }\n      }\n    });\n    this.forceUpdate();\n  };\n\n  private moveAllLeft = () => {\n    moveAllLeft(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveOneLeft = () => {\n    moveOneLeft(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveAllRight = () => {\n    moveAllRight(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private moveOneRight = () => {\n    moveOneRight(elements, getSelectedIndices(elements));\n    this.forceUpdate();\n  };\n\n  private removeWheelEventListener: (() => void) | undefined;\n\n  private updateProjectName(name: string): void {\n    this.setState({ name });\n  }\n\n  private changeProperty = (callback: (element: ExcalidrawElement) => void) => {\n    elements.forEach(element => {\n      if (element.isSelected) {\n        callback(element);\n      }\n    });\n\n    this.forceUpdate();\n  };\n\n  private changeOpacity = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.changeProperty(element => (element.opacity = +event.target.value));\n  };\n\n  private changeStrokeColor = (color: string) => {\n    this.changeProperty(element => (element.strokeColor = color));\n    this.setState({ currentItemStrokeColor: color });\n  };\n\n  private changeBackgroundColor = (color: string) => {\n    this.changeProperty(element => (element.backgroundColor = color));\n    this.setState({ currentItemBackgroundColor: color });\n  };\n\n  private copyToClipboard = () => {\n    if (navigator.clipboard) {\n      const text = JSON.stringify(\n        elements.filter(element => element.isSelected)\n      );\n      navigator.clipboard.writeText(text);\n    }\n  };\n\n  private pasteFromClipboard = () => {\n    if (navigator.clipboard) {\n      navigator.clipboard\n        .readText()\n        .then(text => this.addElementsFromPaste(text));\n    }\n  };\n\n  private redrawTextBoundingBox = (element: ExcalidrawTextElement) => {\n    const metrics = measureText(element.text, element.font);\n    element.width = metrics.width;\n    element.height = metrics.height;\n    element.baseline = metrics.baseline;\n    this.forceUpdate();\n  };\n\n  public render() {\n    const canvasWidth = window.innerWidth - CANVAS_WINDOW_OFFSET_LEFT;\n    const canvasHeight = window.innerHeight - CANVAS_WINDOW_OFFSET_TOP;\n\n    return (\n      <div\n        className=\"container\"\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements(elements);\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          this.addElementsFromPaste(paste);\n          e.preventDefault();\n        }}\n      >\n        <div className=\"sidePanel\">\n          <PanelTools\n            activeTool={this.state.elementType}\n            onToolChange={value => {\n              this.setState({ elementType: value });\n              clearSelection(elements);\n              document.documentElement.style.cursor =\n                value === \"text\" ? \"text\" : \"crosshair\";\n              this.forceUpdate();\n            }}\n          />\n          <Panel title=\"Selection\" hide={!someElementIsSelected(elements)}>\n            <PanelSelection\n              onBringForward={this.moveOneRight}\n              onBringToFront={this.moveAllRight}\n              onSendBackward={this.moveOneLeft}\n              onSendToBack={this.moveAllLeft}\n            />\n\n            <PanelColor\n              title=\"Stroke Color\"\n              onColorChange={this.changeStrokeColor}\n              colorValue={getSelectedAttribute(\n                elements,\n                element => element.strokeColor\n              )}\n            />\n\n            {hasBackground(elements) && (\n              <>\n                <PanelColor\n                  title=\"Background Color\"\n                  onColorChange={this.changeBackgroundColor}\n                  colorValue={getSelectedAttribute(\n                    elements,\n                    element => element.backgroundColor\n                  )}\n                />\n\n                <h5>Fill</h5>\n                <ButtonSelect\n                  options={[\n                    { value: \"solid\", text: \"Solid\" },\n                    { value: \"hachure\", text: \"Hachure\" },\n                    { value: \"cross-hatch\", text: \"Cross-hatch\" }\n                  ]}\n                  value={getSelectedAttribute(\n                    elements,\n                    element => element.fillStyle\n                  )}\n                  onChange={value => {\n                    this.changeProperty(element => {\n                      element.fillStyle = value;\n                    });\n                  }}\n                />\n              </>\n            )}\n\n            {hasStroke(elements) && (\n              <>\n                <h5>Stroke Width</h5>\n                <ButtonSelect\n                  options={[\n                    { value: 1, text: \"Thin\" },\n                    { value: 2, text: \"Bold\" },\n                    { value: 4, text: \"Extra Bold\" }\n                  ]}\n                  value={getSelectedAttribute(\n                    elements,\n                    element => element.strokeWidth\n                  )}\n                  onChange={value => {\n                    this.changeProperty(element => {\n                      element.strokeWidth = value;\n                    });\n                  }}\n                />\n\n                <h5>Sloppiness</h5>\n                <ButtonSelect\n                  options={[\n                    { value: 0, text: \"Draftsman\" },\n                    { value: 1, text: \"Artist\" },\n                    { value: 3, text: \"Cartoonist\" }\n                  ]}\n                  value={getSelectedAttribute(\n                    elements,\n                    element => element.roughness\n                  )}\n                  onChange={value =>\n                    this.changeProperty(element => {\n                      element.roughness = value;\n                    })\n                  }\n                />\n              </>\n            )}\n\n            {hasText(elements) && (\n              <>\n                <h5>Font size</h5>\n                <ButtonSelect\n                  options={[\n                    { value: 16, text: \"Small\" },\n                    { value: 20, text: \"Medium\" },\n                    { value: 28, text: \"Large\" },\n                    { value: 36, text: \"Very Large\" }\n                  ]}\n                  value={getSelectedAttribute(\n                    elements,\n                    element =>\n                      isTextElement(element) && +element.font.split(\"px \")[0]\n                  )}\n                  onChange={value =>\n                    this.changeProperty(element => {\n                      if (isTextElement(element)) {\n                        element.font = `${value}px ${\n                          element.font.split(\"px \")[1]\n                        }`;\n                        this.redrawTextBoundingBox(element);\n                      }\n                    })\n                  }\n                />\n                <h5>Font familly</h5>\n                <ButtonSelect\n                  options={[\n                    { value: \"Virgil\", text: \"Virgil\" },\n                    { value: \"Helvetica\", text: \"Helvetica\" },\n                    { value: \"Courier\", text: \"Courier\" }\n                  ]}\n                  value={getSelectedAttribute(\n                    elements,\n                    element =>\n                      isTextElement(element) && element.font.split(\"px \")[1]\n                  )}\n                  onChange={value =>\n                    this.changeProperty(element => {\n                      if (isTextElement(element)) {\n                        element.font = `${\n                          element.font.split(\"px \")[0]\n                        }px ${value}`;\n                        this.redrawTextBoundingBox(element);\n                      }\n                    })\n                  }\n                />\n              </>\n            )}\n\n            <h5>Opacity</h5>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              onChange={this.changeOpacity}\n              value={\n                getSelectedAttribute(elements, element => element.opacity) ||\n                0 /* Put the opacity at 0 if there are two conflicting ones */\n              }\n            />\n\n            <button onClick={this.deleteSelectedElements}>\n              Delete selected\n            </button>\n          </Panel>\n          <PanelCanvas\n            onClearCanvas={this.clearCanvas}\n            onViewBackgroundColorChange={val =>\n              this.setState({ viewBackgroundColor: val })\n            }\n            viewBackgroundColor={this.state.viewBackgroundColor}\n          />\n          <PanelExport\n            projectName={this.state.name}\n            onProjectNameChange={this.updateProjectName}\n            onExportAsPNG={() =>\n              exportAsPNG(elements, this.canvas!, this.state)\n            }\n            exportBackground={this.state.exportBackground}\n            onExportBackgroundChange={val =>\n              this.setState({ exportBackground: val })\n            }\n            onSaveScene={() => saveAsJSON(elements, this.state.name)}\n            onLoadScene={() =>\n              loadFromJSON(elements).then(() => this.forceUpdate())\n            }\n          />\n        </div>\n        <canvas\n          id=\"canvas\"\n          style={{\n            width: canvasWidth,\n            height: canvasHeight\n          }}\n          width={canvasWidth * window.devicePixelRatio}\n          height={canvasHeight * window.devicePixelRatio}\n          ref={canvas => {\n            if (this.canvas === null) {\n              this.canvas = canvas;\n              this.rc = rough.canvas(this.canvas!);\n            }\n            if (this.removeWheelEventListener) {\n              this.removeWheelEventListener();\n              this.removeWheelEventListener = undefined;\n            }\n            if (canvas) {\n              canvas.addEventListener(\"wheel\", this.handleWheel, {\n                passive: false\n              });\n              this.removeWheelEventListener = () =>\n                canvas.removeEventListener(\"wheel\", this.handleWheel);\n\n              // Whenever React sets the width/height of the canvas element,\n              // the context loses the scale transform. We need to re-apply it\n              if (\n                canvasWidth !== lastCanvasWidth ||\n                canvasHeight !== lastCanvasHeight\n              ) {\n                lastCanvasWidth = canvasWidth;\n                lastCanvasHeight = canvasHeight;\n                canvas\n                  .getContext(\"2d\")!\n                  .scale(window.devicePixelRatio, window.devicePixelRatio);\n              }\n            }\n          }}\n          onContextMenu={e => {\n            e.preventDefault();\n\n            const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n\n            const element = getElementAtPosition(elements, x, y);\n            if (!element) {\n              ContextMenu.push({\n                options: [\n                  navigator.clipboard && {\n                    label: \"Paste\",\n                    action: () => this.pasteFromClipboard()\n                  }\n                ],\n                top: e.clientY,\n                left: e.clientX\n              });\n              return;\n            }\n\n            if (!element.isSelected) {\n              clearSelection(elements);\n              element.isSelected = true;\n              this.forceUpdate();\n            }\n\n            ContextMenu.push({\n              options: [\n                navigator.clipboard && {\n                  label: \"Copy\",\n                  action: this.copyToClipboard\n                },\n                navigator.clipboard && {\n                  label: \"Paste\",\n                  action: () => this.pasteFromClipboard()\n                },\n                { label: \"Copy Styles\", action: this.copyStyles },\n                { label: \"Paste Styles\", action: this.pasteStyles },\n                { label: \"Delete\", action: this.deleteSelectedElements },\n                { label: \"Move Forward\", action: this.moveOneRight },\n                { label: \"Send to Front\", action: this.moveAllRight },\n                { label: \"Move Backwards\", action: this.moveOneLeft },\n                { label: \"Send to Back\", action: this.moveAllLeft }\n              ],\n              top: e.clientY,\n              left: e.clientX\n            });\n          }}\n          onMouseDown={e => {\n            if (lastMouseUp !== null) {\n              // Unfortunately, sometimes we don't get a mouseup after a mousedown,\n              // this can happen when a contextual menu or alert is triggered. In order to avoid\n              // being in a weird state, we clean up on the next mousedown\n              lastMouseUp(e);\n            }\n            // only handle left mouse button\n            if (e.button !== 0) return;\n            // fixes mousemove causing selection of UI texts #32\n            e.preventDefault();\n            // Preventing the event above disables default behavior\n            //  of defocusing potentially focused input, which is what we want\n            //  when clicking inside the canvas.\n            if (isInputLike(document.activeElement)) {\n              document.activeElement.blur();\n            }\n\n            // Handle scrollbars dragging\n            const {\n              isOverHorizontalScrollBar,\n              isOverVerticalScrollBar\n            } = isOverScrollBars(\n              elements,\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT,\n              e.clientY - CANVAS_WINDOW_OFFSET_TOP,\n              canvasWidth,\n              canvasHeight,\n              this.state.scrollX,\n              this.state.scrollY\n            );\n\n            const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            );\n            type ResizeTestType = ReturnType<typeof resizeTest>;\n            let resizeHandle: ResizeTestType = false;\n            let isDraggingElements = false;\n            let isResizingElements = false;\n            if (this.state.elementType === \"selection\") {\n              const resizeElement = getElementWithResizeHandler(\n                elements,\n                { x, y },\n                this.state\n              );\n\n              this.setState({\n                resizingElement: resizeElement ? resizeElement.element : null\n              });\n\n              if (resizeElement) {\n                resizeHandle = resizeElement.resizeHandle;\n                document.documentElement.style.cursor = `${resizeHandle}-resize`;\n                isResizingElements = true;\n              } else {\n                const hitElement = getElementAtPosition(elements, x, y);\n\n                // If we click on something\n                if (hitElement) {\n                  if (hitElement.isSelected) {\n                    // If that element is already selected, do nothing,\n                    // we're likely going to drag it\n                  } else {\n                    // We unselect every other elements unless shift is pressed\n                    if (!e.shiftKey) {\n                      clearSelection(elements);\n                    }\n                  }\n                  // No matter what, we select it\n                  hitElement.isSelected = true;\n                  // We duplicate the selected element if alt is pressed on Mouse down\n                  if (e.altKey) {\n                    elements.push(\n                      ...elements.reduce((duplicates, element) => {\n                        if (element.isSelected) {\n                          duplicates.push(duplicateElement(element));\n                          element.isSelected = false;\n                        }\n                        return duplicates;\n                      }, [] as typeof elements)\n                    );\n                  }\n                } else {\n                  // If we don't click on anything, let's remove all the selected elements\n                  clearSelection(elements);\n                }\n\n                isDraggingElements = someElementIsSelected(elements);\n\n                if (isDraggingElements) {\n                  document.documentElement.style.cursor = \"move\";\n                }\n              }\n            }\n\n            if (isTextElement(element)) {\n              let textX = e.clientX;\n              let textY = e.clientY;\n              if (!e.altKey) {\n                const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n                  x,\n                  y\n                );\n                if (snappedToCenterPosition) {\n                  element.x = snappedToCenterPosition.elementCenterX;\n                  element.y = snappedToCenterPosition.elementCenterY;\n                  textX = snappedToCenterPosition.wysiwygX;\n                  textY = snappedToCenterPosition.wysiwygY;\n                }\n              }\n\n              textWysiwyg({\n                initText: \"\",\n                x: textX,\n                y: textY,\n                strokeColor: this.state.currentItemStrokeColor,\n                font: this.state.currentItemFont,\n                onSubmit: text => {\n                  addTextElement(element, text, this.state.currentItemFont);\n                  elements.push(element);\n                  element.isSelected = true;\n                  this.setState({\n                    draggingElement: null,\n                    elementType: \"selection\"\n                  });\n                }\n              });\n              return;\n            }\n\n            elements.push(element);\n            if (this.state.elementType === \"text\") {\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              element.isSelected = true;\n            } else {\n              this.setState({ draggingElement: element });\n            }\n\n            let lastX = x;\n            let lastY = y;\n\n            if (isOverHorizontalScrollBar || isOverVerticalScrollBar) {\n              lastX = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n              lastY = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n            }\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isOverHorizontalScrollBar) {\n                const x = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n                const dx = x - lastX;\n                this.setState(state => ({ scrollX: state.scrollX - dx }));\n                lastX = x;\n                return;\n              }\n\n              if (isOverVerticalScrollBar) {\n                const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n                const dy = y - lastY;\n                this.setState(state => ({ scrollY: state.scrollY - dy }));\n                lastY = y;\n                return;\n              }\n\n              if (isResizingElements && this.state.resizingElement) {\n                const el = this.state.resizingElement;\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length === 1) {\n                  const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n\n                  selectedElements.forEach(element => {\n                    switch (resizeHandle) {\n                      case \"nw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        if (e.shiftKey) {\n                          element.y += element.height - element.width;\n                          element.height = element.width;\n                        } else {\n                          element.height += element.y - lastY;\n                          element.y = lastY;\n                        }\n                        break;\n                      case \"ne\":\n                        element.width = lastX - element.x;\n                        if (e.shiftKey) {\n                          element.y += element.height - element.width;\n                          element.height = element.width;\n                        } else {\n                          element.height += element.y - lastY;\n                          element.y = lastY;\n                        }\n                        break;\n                      case \"sw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height = lastY - element.y;\n                        }\n                        break;\n                      case \"se\":\n                        element.width += x - lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height += y - lastY;\n                        }\n                        break;\n                      case \"n\":\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"w\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        break;\n                      case \"s\":\n                        element.height = lastY - element.y;\n                        break;\n                      case \"e\":\n                        element.width = lastX - element.x;\n                        break;\n                    }\n\n                    el.x = element.x;\n                    el.y = element.y;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when resizing an element\n                  history.skipRecording();\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when dragging an element to initially size it\n                  history.skipRecording();\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width =\n                e.clientX -\n                CANVAS_WINDOW_OFFSET_LEFT -\n                draggingElement.x -\n                this.state.scrollX;\n              let height =\n                e.clientY -\n                CANVAS_WINDOW_OFFSET_TOP -\n                draggingElement.y -\n                this.state.scrollY;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey\n                ? Math.abs(width) * Math.sign(height)\n                : height;\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(elements, draggingElement);\n              }\n              // We don't want to save history when moving an element\n              history.skipRecording();\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              lastMouseUp = null;\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              resetCursor();\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection(elements);\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            lastMouseUp = onMouseUp;\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            // We don't want to save history on mouseDown, only on mouseUp when it's fully configured\n            history.skipRecording();\n            this.forceUpdate();\n          }}\n          onDoubleClick={e => {\n            const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n\n            const elementAtPosition = getElementAtPosition(elements, x, y);\n\n            const element = newElement(\n              \"text\",\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            ) as ExcalidrawTextElement;\n\n            let initText = \"\";\n            let textX = e.clientX;\n            let textY = e.clientY;\n\n            if (elementAtPosition && isTextElement(elementAtPosition)) {\n              elements.splice(elements.indexOf(elementAtPosition), 1);\n              this.forceUpdate();\n\n              Object.assign(element, elementAtPosition);\n              // x and y will change after calling addTextElement function\n              element.x = elementAtPosition.x + elementAtPosition.width / 2;\n              element.y = elementAtPosition.y + elementAtPosition.height / 2;\n              initText = elementAtPosition.text;\n              textX =\n                this.state.scrollX +\n                elementAtPosition.x +\n                CANVAS_WINDOW_OFFSET_LEFT +\n                elementAtPosition.width / 2;\n              textY =\n                this.state.scrollY +\n                elementAtPosition.y +\n                CANVAS_WINDOW_OFFSET_TOP +\n                elementAtPosition.height / 2;\n            } else if (!e.altKey) {\n              const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n                x,\n                y\n              );\n\n              if (snappedToCenterPosition) {\n                element.x = snappedToCenterPosition.elementCenterX;\n                element.y = snappedToCenterPosition.elementCenterY;\n                textX = snappedToCenterPosition.wysiwygX;\n                textY = snappedToCenterPosition.wysiwygY;\n              }\n            }\n\n            textWysiwyg({\n              initText,\n              x: textX,\n              y: textY,\n              strokeColor: element.strokeColor,\n              font: element.font || this.state.currentItemFont,\n              onSubmit: text => {\n                addTextElement(\n                  element,\n                  text,\n                  element.font || this.state.currentItemFont\n                );\n                elements.push(element);\n                element.isSelected = true;\n                this.setState({\n                  draggingElement: null,\n                  elementType: \"selection\"\n                });\n              }\n            });\n          }}\n          onMouseMove={e => {\n            const hasDeselectedButton = Boolean(e.buttons);\n            if (hasDeselectedButton || this.state.elementType !== \"selection\") {\n              return;\n            }\n            const { x, y } = viewportCoordsToSceneCoords(e, this.state);\n            const resizeElement = getElementWithResizeHandler(\n              elements,\n              { x, y },\n              this.state\n            );\n            if (resizeElement && resizeElement.resizeHandle) {\n              document.documentElement.style.cursor = `${resizeElement.resizeHandle}-resize`;\n              return;\n            }\n            const hitElement = getElementAtPosition(elements, x, y);\n            if (hitElement) {\n              const resizeHandle = resizeTest(hitElement, x, y, {\n                scrollX: this.state.scrollX,\n                scrollY: this.state.scrollY\n              });\n              document.documentElement.style.cursor = resizeHandle\n                ? `${resizeHandle}-resize`\n                : `move`;\n            } else {\n              document.documentElement.style.cursor = ``;\n            }\n          }}\n        />\n      </div>\n    );\n  }\n\n  private handleWheel = (e: WheelEvent) => {\n    e.preventDefault();\n    const { deltaX, deltaY } = e;\n    this.setState(state => ({\n      scrollX: state.scrollX - deltaX,\n      scrollY: state.scrollY - deltaY\n    }));\n  };\n\n  private addElementsFromPaste = (paste: string) => {\n    let parsedElements;\n    try {\n      parsedElements = JSON.parse(paste);\n    } catch (e) {}\n    if (\n      Array.isArray(parsedElements) &&\n      parsedElements.length > 0 &&\n      parsedElements[0].type // need to implement a better check here...\n    ) {\n      clearSelection(elements);\n\n      let subCanvasX1 = Infinity;\n      let subCanvasX2 = 0;\n      let subCanvasY1 = Infinity;\n      let subCanvasY2 = 0;\n\n      const minX = Math.min(...parsedElements.map(element => element.x));\n      const minY = Math.min(...parsedElements.map(element => element.y));\n\n      const distance = (x: number, y: number) => {\n        return Math.abs(x > y ? x - y : y - x);\n      };\n\n      parsedElements.forEach(parsedElement => {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(parsedElement);\n        subCanvasX1 = Math.min(subCanvasX1, x1);\n        subCanvasY1 = Math.min(subCanvasY1, y1);\n        subCanvasX2 = Math.max(subCanvasX2, x2);\n        subCanvasY2 = Math.max(subCanvasY2, y2);\n      });\n\n      const elementsCenterX = distance(subCanvasX1, subCanvasX2) / 2;\n      const elementsCenterY = distance(subCanvasY1, subCanvasY2) / 2;\n\n      const dx =\n        this.state.cursorX -\n        this.state.scrollX -\n        CANVAS_WINDOW_OFFSET_LEFT -\n        elementsCenterX;\n      const dy =\n        this.state.cursorY -\n        this.state.scrollY -\n        CANVAS_WINDOW_OFFSET_TOP -\n        elementsCenterY;\n\n      parsedElements.forEach(parsedElement => {\n        const duplicate = duplicateElement(parsedElement);\n        duplicate.x += dx - minX;\n        duplicate.y += dy - minY;\n        elements.push(duplicate);\n      });\n\n      this.forceUpdate();\n    }\n  };\n\n  private getTextWysiwygSnappedToCenterPosition(x: number, y: number) {\n    const elementClickedInside = getElementContainingPosition(elements, x, y);\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const wysiwygX =\n          this.state.scrollX +\n          elementClickedInside.x +\n          CANVAS_WINDOW_OFFSET_LEFT +\n          elementClickedInside.width / 2;\n        const wysiwygY =\n          this.state.scrollY +\n          elementClickedInside.y +\n          CANVAS_WINDOW_OFFSET_TOP +\n          elementClickedInside.height / 2;\n        return { wysiwygX, wysiwygY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    renderScene(elements, this.rc!, this.canvas!, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor\n    });\n    saveToLocalStorage(elements, this.state);\n    if (history.isRecording()) {\n      history.pushEntry(history.generateCurrentEntry(elements));\n      history.clearRedoStack();\n    }\n    history.resumeRecording();\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n","import { ExcalidrawElement } from \"../element/types\";\n\nexport const createScene = () => {\n  const elements = Array.of<ExcalidrawElement>();\n  return { elements };\n};\n"],"sourceRoot":""}