{"version":3,"sources":["zindex.ts","random.ts","math.ts","roundRect.ts","components/EditableText.tsx","index.tsx"],"names":["swap","elements","indexA","indexB","element","moveOneLeft","indicesToMove","sort","a","b","isSorted","forEach","index","i","moveOneRight","reversedIndicesToMove","length","moveAllLeft","leftMostElements","map","reverse","concat","pos","moveAllRight","rightMostElements","randomSeed","Math","floor","random","withCustomMathRandom","seed","cb","imul","LCG","result","distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","hypot","roundRect","context","width","height","radius","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","stroke","EditableText","props","state","value","edit","this","setState","e","target","onChange","className","name","maxLength","handleEdit","onBlur","handleBlur","onKeyDown","key","autoFocus","onClick","Component","Array","of","DEFAULT_PROJECT_NAME","date","Date","year","getFullYear","month","getMonth","day","getDate","hr","getHours","min","getMinutes","secs","getSeconds","getDateTime","skipHistory","stateHistory","redoStack","generateHistoryCurrentEntry","JSON","stringify","isSelected","restoreHistoryEntry","entry","newElements","parse","splice","newElement","generateDraw","push","hitTest","type","px","abs","py","tx","ty","ex","ey","rx","ry","qx","qy","r","q","max","t","getElementAbsoluteX1","getElementAbsoluteX2","getElementAbsoluteY1","getElementAbsoluteY2","getDiamondPoints","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","getArrowPoints","x3","y3","x4","y4","console","warn","Error","resizeTest","sceneState","handlers","handlerRectangles","filter","Object","keys","handler","scrollX","scrollY","strokeColor","backgroundColor","fillStyle","strokeWidth","roughness","opacity","draw","rc","getScrollBars","canvasWidth","canvasHeight","minX","Infinity","maxX","minY","maxY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","horizontalScrollBar","SCROLLBAR_MARGIN","verticalScrollBar","SCROLLBAR_WIDTH","horizontal","vertical","elementX1","elementX2","elementY1","elementY2","marginX","marginY","nw","se","renderScene","canvas","offsetX","offsetY","renderScrollbars","renderSelection","getContext","viewBackgroundColor","fillRect","clearRect","selectedIndices","getSelectedIndices","lineDash","getLineDash","setLineDash","strokeRect","margin","values","scrollBars","window","devicePixelRatio","strokeStyle","scrollBar","saveFile","data","link","document","createElement","setAttribute","click","remove","rotate","angle","cos","sin","generator","rough","isTextElement","isInputLike","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","distance","minSize","xs","ys","PI","shape","rectangle","globalAlpha","translate","polygon","ellipse","options","shapes","line","font","fillText","text","actualBoundingBoxAscent","clearSelection","resetCursor","documentElement","style","cursor","deleteSelectedElements","restore","savedElements","savedState","undefined","KEYS","SHAPES","icon","viewBox","d","shapesShortcutKeys","capitalize","str","charAt","toUpperCase","slice","findElementByKey","reduce","isArrowKey","keyCode","someElementIsSelected","some","getSelectedAttribute","getAttribute","attributes","from","Set","addTextElement","prompt","textMeasure","measureText","actualBoundingBoxDescent","getElementAtPosition","hitElement","ButtonSelect","option","ColorPicker","color","React","useState","isActive","setActive","colors","changedColor","hex","lastCanvasWidth","lastCanvasHeight","lastMouseUp","App","draggingElement","resizingElement","elementType","exportBackground","currentItemStrokeColor","currentItemBackgroundColor","onResize","forceUpdate","event","preventDefault","step","shiftKey","metaKey","altKey","code","includes","toLowerCase","currentEntry","entryToRestore","pop","lastEntry","clearCanvas","confirm","removeWheelEventListener","changeProperty","callback","changeOpacity","changeStrokeColor","changeBackgroundColor","handleWheel","deltaX","deltaY","addEventListener","localStorage","getItem","removeEventListener","innerWidth","innerHeight","onCut","clipboardData","setData","onCopy","onPaste","parsedElements","paste","getData","isArray","parsedElement","title","checked","updateProjectName","exportPadding","alert","subCanvasX1","subCanvasX2","subCanvasY1","subCanvasY2","tempCanvas","display","body","appendChild","toDataURL","exportAsPNG","serialized","version","source","location","origin","encodeURIComponent","saveAsJSON","input","reader","FileReader","accept","onchange","files","readAsText","Promise","resolve","onloadend","readyState","DONE","loadFromJSON","then","id","ref","passive","scale","onMouseDown","button","activeElement","blur","isOverHorizontalScrollBar","isOverVerticalScrollBar","isOverScrollBars","clientX","clientY","resizeHandle","isDraggingElements","isResizingElements","resizeElement","find","lastX","lastY","onMouseMove","HTMLElement","el","selectedElements","sign","selection","selectionX1","selectionX2","selectionY1","selectionY2","setSelection","onMouseUp","onDoubleClick","newEntry","setItem","rootElement","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.38903582.chunk.js","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n}\n\nexport function moveOneRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n  let isSorted = true;\n\n  // We go from right to left to avoid overriding the wrong elements\n  reversedIndicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index + 1, index);\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beggining\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beggining\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\nexport function moveAllRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n\n  // Copy the elements to move\n  const rightMostElements = reversedIndicesToMove.map(index => elements[index]);\n\n  indicesToMove = reversedIndicesToMove\n    // We go from left to right to avoid overriding elements.\n    .reverse()\n    // We last element index for the final marker\n    .concat([elements.length]);\n\n  indicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the left (i - 1) to the current one (index)\n    for (let pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  });\n\n  // The final step\n  rightMostElements.forEach((element, i) => {\n    elements[elements.length - i - 1] = element;\n  });\n}\n","// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316\nexport const LCG = (seed: number) => () =>\n  ((2 ** 31 - 1) & (seed = Math.imul(48271, seed))) / 2 ** 31;\n\nexport function randomSeed() {\n  return Math.floor(Math.random() * 2 ** 31);\n}\n\n// Unfortunately, roughjs doesn't support a seed attribute (https://github.com/pshihn/rough/issues/27).\n// We can achieve the same result by overriding the Math.random function with a\n// pseudo random generator that supports a random seed and swapping it back after.\nexport function withCustomMathRandom<T>(seed: number, cb: () => T): T {\n  const random = Math.random;\n  Math.random = LCG(seed);\n  const result = cb();\n  Math.random = random;\n  return result;\n}\n","// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport function roundRect(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number\n) {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n}\n","import React, { Fragment, Component } from \"react\";\n\ntype InputState = {\n  value: string;\n  edit: boolean;\n};\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport default class EditableText extends Component<Props, InputState> {\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      value: props.value,\n      edit: false\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(props: Props) {\n    this.setState({ value: props.value });\n  }\n\n  private handleEdit(e: React.ChangeEvent<HTMLInputElement>) {\n    this.setState({ value: e.target.value });\n  }\n\n  private handleBlur() {\n    const { value } = this.state;\n\n    if (!value) {\n      this.setState({ value: this.props.value, edit: false });\n      return;\n    }\n    this.props.onChange(value);\n    this.setState({ edit: false });\n  }\n\n  public render() {\n    const { value, edit } = this.state;\n\n    return (\n      <Fragment>\n        {edit ? (\n          <input\n            className=\"project-name-input\"\n            name=\"name\"\n            maxLength={25}\n            value={value}\n            onChange={e => this.handleEdit(e)}\n            onBlur={() => this.handleBlur()}\n            onKeyDown={e => {\n              if (e.key === \"Enter\") {\n                this.handleBlur();\n              }\n            }}\n            autoFocus\n          />\n        ) : (\n          <span\n            onClick={() => this.setState({ edit: true })}\n            className=\"project-name\"\n          >\n            {value}\n          </span>\n        )}\n      </Fragment>\n    );\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport rough from \"roughjs/bin/wrappers/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { TwitterPicker } from \"react-color\";\n\nimport { moveOneLeft, moveAllLeft, moveOneRight, moveAllRight } from \"./zindex\";\nimport { LCG, randomSeed, withCustomMathRandom } from \"./random\";\nimport { distanceBetweenPointAndSegment } from \"./math\";\nimport { roundRect } from \"./roundRect\";\n\nimport EditableText from \"./components/EditableText\";\n\nimport \"./styles.scss\";\n\ntype ExcalidrawElement = ReturnType<typeof newElement>;\ntype ExcalidrawTextElement = ExcalidrawElement & {\n  type: \"text\";\n  font: string;\n  text: string;\n  actualBoundingBoxAscent: number;\n};\n\nconst LOCAL_STORAGE_KEY = \"excalidraw\";\nconst LOCAL_STORAGE_KEY_STATE = \"excalidraw-state\";\n\nconst elements = Array.of<ExcalidrawElement>();\n\nconst DEFAULT_PROJECT_NAME = `excalidraw-${getDateTime()}`;\n\nlet skipHistory = false;\nconst stateHistory: string[] = [];\nconst redoStack: string[] = [];\n\nfunction generateHistoryCurrentEntry() {\n  return JSON.stringify(\n    elements.map(element => ({ ...element, isSelected: false }))\n  );\n}\nfunction pushHistoryEntry(newEntry: string) {\n  if (\n    stateHistory.length > 0 &&\n    stateHistory[stateHistory.length - 1] === newEntry\n  ) {\n    // If the last entry is the same as this one, ignore it\n    return;\n  }\n  stateHistory.push(newEntry);\n}\nfunction restoreHistoryEntry(entry: string) {\n  const newElements = JSON.parse(entry);\n  elements.splice(0, elements.length);\n  newElements.forEach((newElement: ExcalidrawElement) => {\n    generateDraw(newElement);\n    elements.push(newElement);\n  });\n  // When restoring, we shouldn't add an history entry otherwise we'll be stuck with it and can't go back\n  skipHistory = true;\n}\n\nfunction hitTest(element: ExcalidrawElement, x: number, y: number): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = element.width / 2;\n    const b = element.height / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n\n    const [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY\n    ] = getDiamondPoints(element);\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\nfunction resizeTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n  sceneState: SceneState\n): string | false {\n  if (element.type === \"text\") return false;\n\n  const handlers = handlerRectangles(element, sceneState);\n\n  const filter = Object.keys(handlers).filter(key => {\n    const handler = handlers[key];\n\n    return (\n      x + sceneState.scrollX >= handler[0] &&\n      x + sceneState.scrollX <= handler[0] + handler[2] &&\n      y + sceneState.scrollY >= handler[1] &&\n      y + sceneState.scrollY <= handler[1] + handler[3]\n    );\n  });\n\n  if (filter.length > 0) {\n    return filter[0];\n  }\n\n  return false;\n}\n\nfunction newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  fillStyle: string,\n  strokeWidth: number,\n  roughness: number,\n  opacity: number,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    type: type,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    isSelected: false,\n    strokeColor: strokeColor,\n    backgroundColor: backgroundColor,\n    fillStyle: fillStyle,\n    strokeWidth: strokeWidth,\n    roughness: roughness,\n    opacity: opacity,\n    seed: randomSeed(),\n    draw(\n      rc: RoughCanvas,\n      context: CanvasRenderingContext2D,\n      sceneState: SceneState\n    ) {}\n  };\n  return element;\n}\n\ntype SceneState = {\n  scrollX: number;\n  scrollY: number;\n  // null indicates transparent bg\n  viewBackgroundColor: string | null;\n};\n\nconst SCROLLBAR_WIDTH = 6;\nconst SCROLLBAR_MIN_SIZE = 15;\nconst SCROLLBAR_MARGIN = 4;\nconst SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\nconst CANVAS_WINDOW_OFFSET_LEFT = 250;\nconst CANVAS_WINDOW_OFFSET_TOP = 0;\n\nfunction getScrollBars(\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  let minX = Infinity;\n  let maxX = 0;\n  let minY = Infinity;\n  let maxY = 0;\n\n  elements.forEach(element => {\n    minX = Math.min(minX, getElementAbsoluteX1(element));\n    maxX = Math.max(maxX, getElementAbsoluteX2(element));\n    minY = Math.min(minY, getElementAbsoluteY1(element));\n    maxY = Math.max(maxY, getElementAbsoluteY2(element));\n  });\n\n  minX += scrollX;\n  maxX += scrollX;\n  minY += scrollY;\n  maxY += scrollY;\n  const leftOverflow = Math.max(-minX, 0);\n  const rightOverflow = Math.max(-(canvasWidth - maxX), 0);\n  const topOverflow = Math.max(-minY, 0);\n  const bottomOverflow = Math.max(-(canvasHeight - maxY), 0);\n\n  // horizontal scrollbar\n  let horizontalScrollBar = null;\n  if (leftOverflow || rightOverflow) {\n    horizontalScrollBar = {\n      x: Math.min(\n        leftOverflow + SCROLLBAR_MARGIN,\n        canvasWidth - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      y: canvasHeight - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      width: Math.max(\n        canvasWidth - rightOverflow - leftOverflow - SCROLLBAR_MARGIN * 2,\n        SCROLLBAR_MIN_SIZE\n      ),\n      height: SCROLLBAR_WIDTH\n    };\n  }\n\n  // vertical scrollbar\n  let verticalScrollBar = null;\n  if (topOverflow || bottomOverflow) {\n    verticalScrollBar = {\n      x: canvasWidth - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n      y: Math.min(\n        topOverflow + SCROLLBAR_MARGIN,\n        canvasHeight - SCROLLBAR_MIN_SIZE - SCROLLBAR_MARGIN\n      ),\n      width: SCROLLBAR_WIDTH,\n      height: Math.max(\n        canvasHeight - bottomOverflow - topOverflow - SCROLLBAR_WIDTH * 2,\n        SCROLLBAR_MIN_SIZE\n      )\n    };\n  }\n\n  return {\n    horizontal: horizontalScrollBar,\n    vertical: verticalScrollBar\n  };\n}\n\nfunction isOverScrollBars(\n  x: number,\n  y: number,\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  const scrollBars = getScrollBars(canvasWidth, canvasHeight, scrollX, scrollY);\n\n  const [isOverHorizontalScrollBar, isOverVerticalScrollBar] = [\n    scrollBars.horizontal,\n    scrollBars.vertical\n  ].map(\n    scrollBar =>\n      scrollBar &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n  );\n\n  return {\n    isOverHorizontalScrollBar,\n    isOverVerticalScrollBar\n  };\n}\n\nfunction handlerRectangles(element: ExcalidrawElement, sceneState: SceneState) {\n  const elementX1 = element.x;\n  const elementX2 = element.x + element.width;\n  const elementY1 = element.y;\n  const elementY2 = element.y + element.height;\n\n  const margin = 4;\n  const minimumSize = 40;\n  const handlers: { [handler: string]: number[] } = {};\n\n  const marginX = element.width < 0 ? 8 : -8;\n  const marginY = element.height < 0 ? 8 : -8;\n\n  if (Math.abs(elementX2 - elementX1) > minimumSize) {\n    handlers[\"n\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY1 - margin + sceneState.scrollY + marginY,\n      8,\n      8\n    ];\n\n    handlers[\"s\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY2 - margin + sceneState.scrollY - marginY,\n      8,\n      8\n    ];\n  }\n\n  if (Math.abs(elementY2 - elementY1) > minimumSize) {\n    handlers[\"w\"] = [\n      elementX1 - margin + sceneState.scrollX + marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n\n    handlers[\"e\"] = [\n      elementX2 - margin + sceneState.scrollX - marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n  }\n\n  handlers[\"nw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // nw\n  handlers[\"ne\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // ne\n  handlers[\"sw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // sw\n  handlers[\"se\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // se\n\n  if (element.type === \"arrow\") {\n    return {\n      nw: handlers.nw,\n      se: handlers.se\n    };\n  }\n\n  return handlers;\n}\n\nfunction renderScene(\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    offsetX,\n    offsetY,\n    renderScrollbars = true,\n    renderSelection = true\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n  } = {}\n) {\n  if (!canvas) return;\n  const context = canvas.getContext(\"2d\")!;\n\n  const fillStyle = context.fillStyle;\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  } else {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  const selectedIndices = getSelectedIndices();\n\n  sceneState = {\n    ...sceneState,\n    scrollX: typeof offsetX === \"number\" ? offsetX : sceneState.scrollX,\n    scrollY: typeof offsetY === \"number\" ? offsetY : sceneState.scrollY\n  };\n\n  elements.forEach(element => {\n    element.draw(rc, context, sceneState);\n    if (renderSelection && element.isSelected) {\n      const margin = 4;\n\n      const elementX1 = getElementAbsoluteX1(element);\n      const elementX2 = getElementAbsoluteX2(element);\n      const elementY1 = getElementAbsoluteY1(element);\n      const elementY2 = getElementAbsoluteY2(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin + sceneState.scrollX,\n        elementY1 - margin + sceneState.scrollY,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n\n      if (element.type !== \"text\" && selectedIndices.length === 1) {\n        const handlers = handlerRectangles(element, sceneState);\n        Object.values(handlers).forEach(handler => {\n          context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n        });\n      }\n    }\n  });\n\n  if (renderScrollbars) {\n    const scrollBars = getScrollBars(\n      context.canvas.width / window.devicePixelRatio,\n      context.canvas.height / window.devicePixelRatio,\n      sceneState.scrollX,\n      sceneState.scrollY\n    );\n\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar)\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2\n        );\n    });\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n  }\n}\n\nfunction saveAsJSON(name: string) {\n  const serialized = JSON.stringify({\n    version: 1,\n    source: window.location.origin,\n    elements\n  });\n\n  saveFile(\n    `${name}.json`,\n    \"data:text/plain;charset=utf-8,\" + encodeURIComponent(serialized)\n  );\n}\n\nfunction loadFromJSON() {\n  const input = document.createElement(\"input\");\n  const reader = new FileReader();\n  input.type = \"file\";\n  input.accept = \".json\";\n\n  input.onchange = () => {\n    if (!input.files!.length) {\n      alert(\"A file was not selected.\");\n      return;\n    }\n\n    reader.readAsText(input.files![0], \"utf8\");\n  };\n\n  input.click();\n\n  return new Promise(resolve => {\n    reader.onloadend = () => {\n      if (reader.readyState === FileReader.DONE) {\n        const data = JSON.parse(reader.result as string);\n        restore(data.elements, null);\n        resolve();\n      }\n    };\n  });\n}\n\nfunction exportAsPNG({\n  exportBackground,\n  exportPadding = 10,\n  viewBackgroundColor,\n  name\n}: {\n  exportBackground: boolean;\n  exportPadding?: number;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  name: string;\n}) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n  // calculate smallest area to fit the contents in\n\n  let subCanvasX1 = Infinity;\n  let subCanvasX2 = 0;\n  let subCanvasY1 = Infinity;\n  let subCanvasY2 = 0;\n\n  elements.forEach(element => {\n    subCanvasX1 = Math.min(subCanvasX1, getElementAbsoluteX1(element));\n    subCanvasX2 = Math.max(subCanvasX2, getElementAbsoluteX2(element));\n    subCanvasY1 = Math.min(subCanvasY1, getElementAbsoluteY1(element));\n    subCanvasY2 = Math.max(subCanvasY2, getElementAbsoluteY2(element));\n  });\n\n  function distance(x: number, y: number) {\n    return Math.abs(x > y ? x - y : y - x);\n  }\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  tempCanvas.width = distance(subCanvasX1, subCanvasX2) + exportPadding * 2;\n  tempCanvas.height = distance(subCanvasY1, subCanvasY2) + exportPadding * 2;\n\n  renderScene(\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: 0,\n      scrollY: 0\n    },\n    {\n      offsetX: -subCanvasX1 + exportPadding,\n      offsetY: -subCanvasY1 + exportPadding,\n      renderScrollbars: false,\n      renderSelection: false\n    }\n  );\n\n  saveFile(`${name}.png`, tempCanvas.toDataURL(\"image/png\"));\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) tempCanvas.remove();\n}\n\nfunction saveFile(name: string, data: string) {\n  // create a temporary <a> elem which we'll use to download the image\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"download\", name);\n  link.setAttribute(\"href\", data);\n  link.click();\n\n  // clean up\n  link.remove();\n}\n\nfunction rotate(x1: number, y1: number, x2: number, y2: number, angle: number) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n\nfunction getDateTime() {\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const hr = date.getHours();\n  const min = date.getMinutes();\n  const secs = date.getSeconds();\n\n  return `${year}${month}${day}${hr}${min}${secs}`;\n}\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nconst generator = rough.generator(null, null as any);\n\nfunction isTextElement(\n  element: ExcalidrawElement\n): element is ExcalidrawTextElement {\n  return element.type === \"text\";\n}\n\nfunction isInputLike(\n  target: Element | EventTarget | null\n): target is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\n  return (\n    target instanceof HTMLInputElement ||\n    target instanceof HTMLTextAreaElement ||\n    target instanceof HTMLSelectElement\n  );\n}\n\nfunction getArrowPoints(element: ExcalidrawElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n\nfunction getDiamondPoints(element: ExcalidrawElement) {\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\n\nfunction generateDraw(element: ExcalidrawElement) {\n  if (element.type === \"selection\") {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(\n        element.x + scrollX,\n        element.y + scrollY,\n        element.width,\n        element.height\n      );\n      context.fillStyle = fillStyle;\n    };\n  } else if (element.type === \"rectangle\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      return generator.rectangle(0, 0, element.width, element.height, {\n        stroke: element.strokeColor,\n        fill: element.backgroundColor,\n        fillStyle: element.fillStyle,\n        strokeWidth: element.strokeWidth,\n        roughness: element.roughness\n      });\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"diamond\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      const [\n        topX,\n        topY,\n        rightX,\n        rightY,\n        bottomX,\n        bottomY,\n        leftX,\n        leftY\n      ] = getDiamondPoints(element);\n      return generator.polygon(\n        [\n          [topX, topY],\n          [rightX, rightY],\n          [bottomX, bottomY],\n          [leftX, leftY]\n        ],\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      );\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"ellipse\") {\n    const shape = withCustomMathRandom(element.seed, () =>\n      generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness\n        }\n      )\n    );\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const options = {\n      stroke: element.strokeColor,\n      strokeWidth: element.strokeWidth,\n      roughness: element.roughness\n    };\n\n    const shapes = withCustomMathRandom(element.seed, () => [\n      //    \\\n      generator.line(x3, y3, x2, y2, options),\n      // -----\n      generator.line(x1, y1, x2, y2, options),\n      //    /\n      generator.line(x4, y4, x2, y2, options)\n    ]);\n\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      context.translate(element.x + scrollX, element.y + scrollY);\n      shapes.forEach(shape => rc.draw(shape));\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n      context.globalAlpha = 1;\n    };\n    return;\n  } else if (isTextElement(element)) {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.globalAlpha = element.opacity / 100;\n      const font = context.font;\n      context.font = element.font;\n      const fillStyle = context.fillStyle;\n      context.fillStyle = element.strokeColor;\n      context.fillText(\n        element.text,\n        element.x + scrollX,\n        element.y + element.actualBoundingBoxAscent + scrollY\n      );\n      context.fillStyle = fillStyle;\n      context.font = font;\n      context.globalAlpha = 1;\n    };\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nfunction getElementAbsoluteX1(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x : element.x + element.width;\n}\nfunction getElementAbsoluteX2(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x + element.width : element.x;\n}\nfunction getElementAbsoluteY1(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y : element.y + element.height;\n}\nfunction getElementAbsoluteY2(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y + element.height : element.y;\n}\n\nfunction setSelection(selection: ExcalidrawElement) {\n  const selectionX1 = getElementAbsoluteX1(selection);\n  const selectionX2 = getElementAbsoluteX2(selection);\n  const selectionY1 = getElementAbsoluteY1(selection);\n  const selectionY2 = getElementAbsoluteY2(selection);\n  elements.forEach(element => {\n    const elementX1 = getElementAbsoluteX1(element);\n    const elementX2 = getElementAbsoluteX2(element);\n    const elementY1 = getElementAbsoluteY1(element);\n    const elementY2 = getElementAbsoluteY2(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nfunction clearSelection() {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nfunction resetCursor() {\n  document.documentElement.style.cursor = \"\";\n}\n\nfunction deleteSelectedElements() {\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\nfunction save(state: AppState) {\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(elements));\n  localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(state));\n}\n\nfunction restoreFromLocalStorage() {\n  const savedElements = localStorage.getItem(LOCAL_STORAGE_KEY);\n  const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_STATE);\n\n  return restore(savedElements, savedState);\n}\n\nfunction restore(\n  savedElements: string | ExcalidrawElement[] | null,\n  savedState: string | null\n) {\n  try {\n    if (savedElements) {\n      elements.splice(\n        0,\n        elements.length,\n        ...(typeof savedElements === \"string\"\n          ? JSON.parse(savedElements)\n          : savedElements)\n      );\n      elements.forEach((element: ExcalidrawElement) => {\n        element.fillStyle = element.fillStyle || \"hachure\";\n        element.strokeWidth = element.strokeWidth || 1;\n        element.roughness = element.roughness || 1;\n        element.opacity =\n          element.opacity === null || element.opacity === undefined\n            ? 100\n            : element.opacity;\n\n        generateDraw(element);\n      });\n    }\n\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (e) {\n    elements.splice(0, elements.length);\n    return null;\n  }\n}\n\ntype AppState = {\n  draggingElement: ExcalidrawElement | null;\n  resizingElement: ExcalidrawElement | null;\n  elementType: string;\n  exportBackground: boolean;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  name: string;\n};\n\nconst KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nconst SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\"\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\"\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\"\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\"\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\"\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\"\n  }\n];\n\nconst shapesShortcutKeys = SHAPES.map(shape => shape.value[0]);\n\nfunction capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction findElementByKey(key: string) {\n  const defaultElement = \"selection\";\n  return SHAPES.reduce((element, shape) => {\n    if (shape.value[0] !== key) return element;\n\n    return shape.value;\n  }, defaultElement);\n}\n\nfunction isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n\nfunction getSelectedIndices() {\n  const selectedIndices: number[] = [];\n  elements.forEach((element, index) => {\n    if (element.isSelected) {\n      selectedIndices.push(index);\n    }\n  });\n  return selectedIndices;\n}\n\nconst someElementIsSelected = () =>\n  elements.some(element => element.isSelected);\n\nconst hasBackground = () =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\")\n  );\n\nconst hasStroke = () =>\n  elements.some(\n    element =>\n      element.isSelected &&\n      (element.type === \"rectangle\" ||\n        element.type === \"ellipse\" ||\n        element.type === \"diamond\" ||\n        element.type === \"arrow\")\n  );\n\nfunction getSelectedAttribute<T>(\n  getAttribute: (element: ExcalidrawElement) => T\n): T | null {\n  const attributes = Array.from(\n    new Set(\n      elements\n        .filter(element => element.isSelected)\n        .map(element => getAttribute(element))\n    )\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n}\n\nfunction addTextElement(element: ExcalidrawTextElement) {\n  resetCursor();\n  const text = prompt(\"What text do you want?\");\n  if (text === null || text === \"\") {\n    return false;\n  }\n  const fontSize = 20;\n  element.text = text;\n  element.font = `${fontSize}px Virgil`;\n  const font = context.font;\n  context.font = element.font;\n  const textMeasure = context.measureText(element.text);\n  const width = textMeasure.width;\n  const actualBoundingBoxAscent =\n    textMeasure.actualBoundingBoxAscent || fontSize;\n  const actualBoundingBoxDescent = textMeasure.actualBoundingBoxDescent || 0;\n  element.actualBoundingBoxAscent = actualBoundingBoxAscent;\n  context.font = font;\n  const height = actualBoundingBoxAscent + actualBoundingBoxDescent;\n  // Center the text\n  element.x -= width / 2;\n  element.y -= actualBoundingBoxAscent;\n  element.width = width;\n  element.height = height;\n\n  return true;\n}\n\nfunction getElementAtPosition(x: number, y: number) {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (hitTest(elements[i], x, y)) {\n      hitElement = elements[i];\n      break;\n    }\n  }\n\n  return hitElement;\n}\n\nfunction ButtonSelect<T>({\n  options,\n  value,\n  onChange\n}: {\n  options: { value: T; text: string }[];\n  value: T | null;\n  onChange: (value: T) => void;\n}) {\n  return (\n    <div className=\"buttonList\">\n      {options.map(option => (\n        <button\n          key={option.text}\n          onClick={() => onChange(option.value)}\n          className={value === option.value ? \"active\" : \"\"}\n        >\n          {option.text}\n        </button>\n      ))}\n    </div>\n  );\n}\n\nfunction ColorPicker({\n  color,\n  onChange\n}: {\n  color: string | null;\n  onChange: (color: string) => void;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  return (\n    <div>\n      <button\n        className=\"swatch\"\n        style={color ? { backgroundColor: color } : undefined}\n        onClick={() => setActive(!isActive)}\n      />\n      {isActive ? (\n        <div className=\"popover\">\n          <div className=\"cover\" onClick={() => setActive(false)} />\n          <TwitterPicker\n            colors={[\n              \"#000000\",\n              \"#ABB8C3\",\n              \"#FFFFFF\",\n              \"#FF6900\",\n              \"#FCB900\",\n              \"#00D084\",\n              \"#8ED1FC\",\n              \"#0693E3\",\n              \"#EB144C\",\n              \"#F78DA7\",\n              \"#9900EF\"\n            ]}\n            width=\"205px\"\n            color={color || undefined}\n            onChange={changedColor => {\n              onChange(changedColor.hex);\n            }}\n          />\n        </div>\n      ) : null}\n      <input\n        type=\"text\"\n        className=\"swatch-input\"\n        value={color || \"\"}\n        onChange={e => onChange(e.target.value)}\n      />\n    </div>\n  );\n}\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\n\nlet lastCanvasWidth = -1;\nlet lastCanvasHeight = -1;\n\nlet lastMouseUp: ((e: any) => void) | null = null;\n\nclass App extends React.Component<{}, AppState> {\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    window.addEventListener(\"resize\", this.onResize, false);\n\n    const savedState = restoreFromLocalStorage();\n    if (savedState) {\n      this.setState(savedState);\n    }\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    window.removeEventListener(\"resize\", this.onResize, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    resizingElement: null,\n    elementType: \"selection\",\n    exportBackground: true,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    viewBackgroundColor: \"#ffffff\",\n    scrollX: 0,\n    scrollY: 0,\n    name: DEFAULT_PROJECT_NAME\n  };\n\n  private onResize = () => {\n    this.forceUpdate();\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (isInputLike(event.target)) return;\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      deleteSelectedElements();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send backward: Cmd-Shift-Alt-B\n    } else if (\n      event.metaKey &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyB\"\n    ) {\n      this.moveOneLeft();\n      event.preventDefault();\n\n      // Send to back: Cmd-Shift-B\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyB\") {\n      this.moveAllLeft();\n      event.preventDefault();\n\n      // Bring forward: Cmd-Shift-Alt-F\n    } else if (\n      event.metaKey &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyF\"\n    ) {\n      this.moveOneRight();\n      event.preventDefault();\n\n      // Bring to front: Cmd-Shift-F\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyF\") {\n      this.moveAllRight();\n      event.preventDefault();\n\n      // Select all: Cmd-A\n    } else if (event.metaKey && event.code === \"KeyA\") {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n      this.setState({ elementType: findElementByKey(event.key) });\n    } else if (event.metaKey && event.code === \"KeyZ\") {\n      const currentEntry = generateHistoryCurrentEntry();\n      if (event.shiftKey) {\n        // Redo action\n        const entryToRestore = redoStack.pop();\n        if (entryToRestore !== undefined) {\n          restoreHistoryEntry(entryToRestore);\n          stateHistory.push(currentEntry);\n        }\n      } else {\n        // undo action\n        let lastEntry = stateHistory.pop();\n        // If nothing was changed since last, take the previous one\n        if (currentEntry === lastEntry) {\n          lastEntry = stateHistory.pop();\n        }\n        if (lastEntry !== undefined) {\n          restoreHistoryEntry(lastEntry);\n          redoStack.push(currentEntry);\n        }\n      }\n      this.forceUpdate();\n      event.preventDefault();\n    }\n  };\n\n  private deleteSelectedElements = () => {\n    deleteSelectedElements();\n    this.forceUpdate();\n  };\n\n  private clearCanvas = () => {\n    if (window.confirm(\"This will clear the whole canvas. Are you sure?\")) {\n      elements.splice(0, elements.length);\n      this.setState({\n        viewBackgroundColor: \"#ffffff\",\n        scrollX: 0,\n        scrollY: 0\n      });\n      this.forceUpdate();\n    }\n  };\n\n  private moveAllLeft = () => {\n    moveAllLeft(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveOneLeft = () => {\n    moveOneLeft(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveAllRight = () => {\n    moveAllRight(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveOneRight = () => {\n    moveOneRight(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private removeWheelEventListener: (() => void) | undefined;\n\n  private updateProjectName(name: string): void {\n    this.setState({ name });\n  }\n\n  private changeProperty = (callback: (element: ExcalidrawElement) => void) => {\n    elements.forEach(element => {\n      if (element.isSelected) {\n        callback(element);\n        generateDraw(element);\n      }\n    });\n\n    this.forceUpdate();\n  };\n\n  private changeOpacity = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.changeProperty(element => (element.opacity = +event.target.value));\n  };\n\n  private changeStrokeColor = (color: string) => {\n    this.changeProperty(element => (element.strokeColor = color));\n    this.setState({ currentItemStrokeColor: color });\n  };\n\n  private changeBackgroundColor = (color: string) => {\n    this.changeProperty(element => (element.backgroundColor = color));\n    this.setState({ currentItemBackgroundColor: color });\n  };\n\n  public render() {\n    const canvasWidth = window.innerWidth - CANVAS_WINDOW_OFFSET_LEFT;\n    const canvasHeight = window.innerHeight - CANVAS_WINDOW_OFFSET_TOP;\n\n    return (\n      <div\n        className=\"container\"\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements();\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          let parsedElements;\n          try {\n            parsedElements = JSON.parse(paste);\n          } catch (e) {}\n          if (\n            Array.isArray(parsedElements) &&\n            parsedElements.length > 0 &&\n            parsedElements[0].type // need to implement a better check here...\n          ) {\n            clearSelection();\n            parsedElements.forEach(parsedElement => {\n              parsedElement.x += 10;\n              parsedElement.y += 10;\n              parsedElement.seed = randomSeed();\n              generateDraw(parsedElement);\n              elements.push(parsedElement);\n            });\n            this.forceUpdate();\n          }\n          e.preventDefault();\n        }}\n      >\n        <div className=\"sidePanel\">\n          <h4>Shapes</h4>\n          <div className=\"panelTools\">\n            {SHAPES.map(({ value, icon }) => (\n              <label\n                key={value}\n                className=\"tool\"\n                title={`${capitalize(value)} - ${capitalize(value)[0]}`}\n              >\n                <input\n                  type=\"radio\"\n                  checked={this.state.elementType === value}\n                  onChange={() => {\n                    this.setState({ elementType: value });\n                    clearSelection();\n                    document.documentElement.style.cursor =\n                      value === \"text\" ? \"text\" : \"crosshair\";\n                    this.forceUpdate();\n                  }}\n                />\n                <div className=\"toolIcon\">{icon}</div>\n              </label>\n            ))}\n          </div>\n          {someElementIsSelected() && (\n            <div className=\"panelColumn\">\n              <h4>Selection</h4>\n              <div className=\"buttonList\">\n                <button onClick={this.moveOneRight}>Bring forward</button>\n                <button onClick={this.moveAllRight}>Bring to front</button>\n                <button onClick={this.moveOneLeft}>Send backward</button>\n                <button onClick={this.moveAllLeft}>Send to back</button>\n              </div>\n              <h5>Stroke Color</h5>\n              <ColorPicker\n                color={getSelectedAttribute(element => element.strokeColor)}\n                onChange={color => this.changeStrokeColor(color)}\n              />\n\n              {hasBackground() && (\n                <>\n                  <h5>Background Color</h5>\n                  <ColorPicker\n                    color={getSelectedAttribute(\n                      element => element.backgroundColor\n                    )}\n                    onChange={color => this.changeBackgroundColor(color)}\n                  />\n                  <h5>Fill</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: \"solid\", text: \"Solid\" },\n                      { value: \"hachure\", text: \"Hachure\" },\n                      { value: \"cross-hatch\", text: \"Cross-hatch\" }\n                    ]}\n                    value={getSelectedAttribute(element => element.fillStyle)}\n                    onChange={value => {\n                      this.changeProperty(element => {\n                        element.fillStyle = value;\n                      });\n                    }}\n                  />\n                </>\n              )}\n\n              {hasStroke() && (\n                <>\n                  <h5>Stroke Width</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: 1, text: \"Thin\" },\n                      { value: 2, text: \"Bold\" },\n                      { value: 4, text: \"Extra Bold\" }\n                    ]}\n                    value={getSelectedAttribute(element => element.strokeWidth)}\n                    onChange={value => {\n                      this.changeProperty(element => {\n                        element.strokeWidth = value;\n                      });\n                    }}\n                  />\n\n                  <h5>Sloppiness</h5>\n                  <ButtonSelect\n                    options={[\n                      { value: 0, text: \"Draftsman\" },\n                      { value: 1, text: \"Artist\" },\n                      { value: 3, text: \"Cartoonist\" }\n                    ]}\n                    value={getSelectedAttribute(element => element.roughness)}\n                    onChange={value =>\n                      this.changeProperty(element => {\n                        element.roughness = value;\n                      })\n                    }\n                  />\n                </>\n              )}\n\n              <h5>Opacity</h5>\n              <input\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                onChange={this.changeOpacity}\n                value={\n                  getSelectedAttribute(element => element.opacity) ||\n                  0 /* Put the opacity at 0 if there are two conflicting ones */\n                }\n              />\n\n              <button onClick={this.deleteSelectedElements}>\n                Delete selected\n              </button>\n            </div>\n          )}\n          <h4>Canvas</h4>\n          <div className=\"panelColumn\">\n            <h5>Canvas Background Color</h5>\n            <ColorPicker\n              color={this.state.viewBackgroundColor}\n              onChange={color => this.setState({ viewBackgroundColor: color })}\n            />\n            <button\n              onClick={this.clearCanvas}\n              title=\"Clear the canvas & reset background color\"\n            >\n              Clear canvas\n            </button>\n          </div>\n          <h4>Export</h4>\n          <div className=\"panelColumn\">\n            <h5>Name</h5>\n            {this.state.name && (\n              <EditableText\n                value={this.state.name}\n                onChange={(name: string) => this.updateProjectName(name)}\n              />\n            )}\n            <h5>Image</h5>\n            <button\n              onClick={() => {\n                exportAsPNG(this.state);\n              }}\n            >\n              Export to png\n            </button>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={this.state.exportBackground}\n                onChange={e => {\n                  this.setState({ exportBackground: e.target.checked });\n                }}\n              />\n              background\n            </label>\n            <h5>Scene</h5>\n            <button\n              onClick={() => {\n                saveAsJSON(this.state.name);\n              }}\n            >\n              Save as...\n            </button>\n            <button\n              onClick={() => {\n                loadFromJSON().then(() => this.forceUpdate());\n              }}\n            >\n              Load file...\n            </button>\n          </div>\n        </div>\n        <canvas\n          id=\"canvas\"\n          style={{\n            width: canvasWidth,\n            height: canvasHeight\n          }}\n          width={canvasWidth * window.devicePixelRatio}\n          height={canvasHeight * window.devicePixelRatio}\n          ref={canvas => {\n            if (this.removeWheelEventListener) {\n              this.removeWheelEventListener();\n              this.removeWheelEventListener = undefined;\n            }\n            if (canvas) {\n              canvas.addEventListener(\"wheel\", this.handleWheel, {\n                passive: false\n              });\n              this.removeWheelEventListener = () =>\n                canvas.removeEventListener(\"wheel\", this.handleWheel);\n\n              // Whenever React sets the width/height of the canvas element,\n              // the context loses the scale transform. We need to re-apply it\n              if (\n                canvasWidth !== lastCanvasWidth ||\n                canvasHeight !== lastCanvasHeight\n              ) {\n                lastCanvasWidth = canvasWidth;\n                lastCanvasHeight = canvasHeight;\n                canvas\n                  .getContext(\"2d\")!\n                  .scale(window.devicePixelRatio, window.devicePixelRatio);\n              }\n            }\n          }}\n          onMouseDown={e => {\n            if (lastMouseUp !== null) {\n              // Unfortunately, sometimes we don't get a mouseup after a mousedown,\n              // this can happen when a contextual menu or alert is triggered. In order to avoid\n              // being in a weird state, we clean up on the next mousedown\n              lastMouseUp(e);\n            }\n            // only handle left mouse button\n            if (e.button !== 0) return;\n            // fixes mousemove causing selection of UI texts #32\n            e.preventDefault();\n            // Preventing the event above disables default behavior\n            //  of defocusing potentially focused input, which is what we want\n            //  when clicking inside the canvas.\n            if (isInputLike(document.activeElement)) {\n              document.activeElement.blur();\n            }\n\n            // Handle scrollbars dragging\n            const {\n              isOverHorizontalScrollBar,\n              isOverVerticalScrollBar\n            } = isOverScrollBars(\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT,\n              e.clientY - CANVAS_WINDOW_OFFSET_TOP,\n              canvasWidth,\n              canvasHeight,\n              this.state.scrollX,\n              this.state.scrollY\n            );\n\n            const x =\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n            const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            );\n            let resizeHandle: string | false = false;\n            let isDraggingElements = false;\n            let isResizingElements = false;\n            if (this.state.elementType === \"selection\") {\n              const resizeElement = elements.find(element => {\n                return resizeTest(element, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n              });\n\n              this.setState({\n                resizingElement: resizeElement ? resizeElement : null\n              });\n\n              if (resizeElement) {\n                resizeHandle = resizeTest(resizeElement, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n                document.documentElement.style.cursor = `${resizeHandle}-resize`;\n                isResizingElements = true;\n              } else {\n                const hitElement = getElementAtPosition(x, y);\n\n                // If we click on something\n                if (hitElement) {\n                  if (hitElement.isSelected) {\n                    // If that element is not already selected, do nothing,\n                    // we're likely going to drag it\n                  } else {\n                    // We unselect every other elements unless shift is pressed\n                    if (!e.shiftKey) {\n                      clearSelection();\n                    }\n                    // No matter what, we select it\n                    hitElement.isSelected = true;\n                  }\n                } else {\n                  // If we don't click on anything, let's remove all the selected elements\n                  clearSelection();\n                }\n\n                isDraggingElements = someElementIsSelected();\n\n                if (isDraggingElements) {\n                  document.documentElement.style.cursor = \"move\";\n                }\n              }\n            }\n\n            if (isTextElement(element)) {\n              if (!addTextElement(element)) {\n                return;\n              }\n            }\n\n            generateDraw(element);\n            elements.push(element);\n            if (this.state.elementType === \"text\") {\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              element.isSelected = true;\n            } else {\n              this.setState({ draggingElement: element });\n            }\n\n            let lastX = x;\n            let lastY = y;\n\n            if (isOverHorizontalScrollBar || isOverVerticalScrollBar) {\n              lastX = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n              lastY = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n            }\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isOverHorizontalScrollBar) {\n                const x = e.clientX - CANVAS_WINDOW_OFFSET_LEFT;\n                const dx = x - lastX;\n                this.setState(state => ({ scrollX: state.scrollX - dx }));\n                lastX = x;\n                return;\n              }\n\n              if (isOverVerticalScrollBar) {\n                const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP;\n                const dy = y - lastY;\n                this.setState(state => ({ scrollY: state.scrollY - dy }));\n                lastY = y;\n                return;\n              }\n\n              if (isResizingElements && this.state.resizingElement) {\n                const el = this.state.resizingElement;\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length === 1) {\n                  const x =\n                    e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n                  const y =\n                    e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    switch (resizeHandle) {\n                      case \"nw\":\n                        element.width += element.x - lastX;\n                        element.height += element.y - lastY;\n                        element.x = lastX;\n                        element.y = lastY;\n                        break;\n                      case \"ne\":\n                        element.width = lastX - element.x;\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"sw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        element.height = lastY - element.y;\n                        break;\n                      case \"se\":\n                        element.width += x - lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height += y - lastY;\n                        }\n                        break;\n                      case \"n\":\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"w\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        break;\n                      case \"s\":\n                        element.height = lastY - element.y;\n                        break;\n                      case \"e\":\n                        element.width = lastX - element.x;\n                        break;\n                    }\n\n                    el.x = element.x;\n                    el.y = element.y;\n                    generateDraw(el);\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when resizing an element\n                  skipHistory = true;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const x =\n                    e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n                  const y =\n                    e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  // We don't want to save history when dragging an element to initially size it\n                  skipHistory = true;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width =\n                e.clientX -\n                CANVAS_WINDOW_OFFSET_LEFT -\n                draggingElement.x -\n                this.state.scrollX;\n              let height =\n                e.clientY -\n                CANVAS_WINDOW_OFFSET_TOP -\n                draggingElement.y -\n                this.state.scrollY;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey\n                ? Math.abs(width) * Math.sign(height)\n                : height;\n\n              generateDraw(draggingElement);\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(draggingElement);\n              }\n              // We don't want to save history when moving an element\n              skipHistory = true;\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              lastMouseUp = null;\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              resetCursor();\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection();\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            lastMouseUp = onMouseUp;\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            // We don't want to save history on mouseDown, only on mouseUp when it's fully configured\n            skipHistory = true;\n            this.forceUpdate();\n          }}\n          onDoubleClick={e => {\n            const x =\n              e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n            const y = e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n\n            if (getElementAtPosition(x, y)) {\n              return;\n            }\n\n            const element = newElement(\n              \"text\",\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              \"hachure\",\n              1,\n              1,\n              100\n            );\n\n            if (!addTextElement(element as ExcalidrawTextElement)) {\n              return;\n            }\n\n            generateDraw(element);\n            elements.push(element);\n\n            this.setState({\n              draggingElement: null,\n              elementType: \"selection\"\n            });\n            element.isSelected = true;\n\n            this.forceUpdate();\n          }}\n        />\n      </div>\n    );\n  }\n\n  private handleWheel = (e: WheelEvent) => {\n    e.preventDefault();\n    const { deltaX, deltaY } = e;\n    this.setState(state => ({\n      scrollX: state.scrollX - deltaX,\n      scrollY: state.scrollY - deltaY\n    }));\n  };\n\n  componentDidUpdate() {\n    renderScene(rc, canvas, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor\n    });\n    save(this.state);\n    if (!skipHistory) {\n      pushHistoryEntry(generateHistoryCurrentEntry());\n      redoStack.splice(0, redoStack.length);\n    }\n    skipHistory = false;\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst rc = rough.canvas(canvas);\nconst context = canvas.getContext(\"2d\")!;\n\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}