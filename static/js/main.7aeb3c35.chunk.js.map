{"version":3,"sources":["index.tsx"],"names":["elements","Array","of","distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","Math","sqrt","renderScene","rc","context","viewBackgroundColor","fillStyle","fillRect","canvas","width","height","clearRect","forEach","element","draw","isSelected","elementX1","getElementAbsoluteX1","elementX2","getElementAbsoluteX2","elementY1","getElementAbsoluteY1","elementY2","getElementAbsoluteY2","lineDash","getLineDash","setLineDash","strokeRect","margin","exportAsPNG","exportBackground","exportVisibleOnly","exportPadding","length","window","alert","clearSelection","ReactDOM","render","App","rootElement","subCanvasX1","Infinity","subCanvasX2","subCanvasY1","subCanvasY2","min","max","tempCanvas","document","createElement","tempCanvasCtx","getContext","style","display","body","appendChild","drawImage","link","setAttribute","toDataURL","click","remove","rotate","angle","cos","sin","generator","rough","isTextElement","type","getArrowPoints","distance","pow","minSize","xs","ys","PI","x3","y3","generateDraw","shape","rectangle","stroke","strokeColor","fill","backgroundColor","translate","ellipse","x4","y4","shapes","line","Error","font","fillText","text","actualBoundingBoxAscent","deleteSelectedElements","i","splice","KEYS","isArrowKey","keyCode","state","draggingElement","elementType","currentItemStrokeColor","currentItemBackgroundColor","onKeyDown","event","target","nodeName","key","forceUpdate","preventDefault","step","shiftKey","metaKey","addEventListener","this","removeEventListener","children","checked","onChange","setState","onCut","e","clipboardData","setData","JSON","stringify","filter","onCopy","onPaste","parsedElements","paste","getData","parse","isArray","parsedElement","push","renderOption","id","innerWidth","innerHeight","onMouseDown","clientX","offsetLeft","clientY","offsetTop","newElement","isDraggingElements","cursorStyle","documentElement","cursor","hitElement","find","hitTest","some","prompt","measureText","actualBoundingBoxDescent","lastX","lastY","onMouseMove","HTMLElement","selectedElements","el","selection","selectionX1","selectionX2","selectionY1","selectionY2","setSelection","onMouseUp","pop","value","onClick","Number","disabled","React","Component","getElementById"],"mappings":"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","file":"static/js/main.7aeb3c35.chunk.js","sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport rough from \"roughjs/bin/wrappers/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport \"./styles.css\";\n\ntype ExcaliburElement = ReturnType<typeof newElement>;\ntype ExcaliburTextElement = ExcaliburElement & {\n  type: \"text\";\n  font: string;\n  text: string;\n  actualBoundingBoxAscent: number;\n};\n\nvar elements = Array.of<ExcaliburElement>();\n\n// https://stackoverflow.com/a/6853926/232122\nfunction distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction hitTest(element: ExcaliburElement, x: number, y: number): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (\n    element.type === \"rectangle\" ||\n    // There doesn't seem to be a closed form solution for the distance between\n    // a point and an ellipse, let's assume it's a rectangle for now...\n    element.type === \"ellipse\"\n  ) {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\nfunction newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    type: type,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    isSelected: false,\n    strokeColor: strokeColor,\n    backgroundColor: backgroundColor,\n    draw(rc: RoughCanvas, context: CanvasRenderingContext2D) {}\n  };\n  return element;\n}\n\nfunction renderScene(\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  // null indicates transparent bg\n  viewBackgroundColor: string | null\n) {\n  const fillStyle = context.fillStyle;\n  if (typeof viewBackgroundColor === \"string\") {\n    context.fillStyle = viewBackgroundColor;\n    context.fillRect(-0.5, -0.5, canvas.width, canvas.height);\n  } else {\n    context.clearRect(-0.5, -0.5, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  elements.forEach(element => {\n    element.draw(rc, context);\n    if (element.isSelected) {\n      const margin = 4;\n\n      const elementX1 = getElementAbsoluteX1(element);\n      const elementX2 = getElementAbsoluteX2(element);\n      const elementY1 = getElementAbsoluteY1(element);\n      const elementY2 = getElementAbsoluteY2(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin,\n        elementY1 - margin,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n    }\n  });\n}\n\nfunction exportAsPNG({\n  exportBackground,\n  exportVisibleOnly,\n  exportPadding = 10,\n  viewBackgroundColor\n}: {\n  exportBackground: boolean;\n  exportVisibleOnly: boolean;\n  exportPadding?: number;\n  viewBackgroundColor: string;\n}) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n\n  // deselect & rerender\n\n  clearSelection();\n  ReactDOM.render(<App />, rootElement, () => {\n    // calculate visible-area coords\n\n    let subCanvasX1 = Infinity;\n    let subCanvasX2 = 0;\n    let subCanvasY1 = Infinity;\n    let subCanvasY2 = 0;\n\n    elements.forEach(element => {\n      subCanvasX1 = Math.min(subCanvasX1, getElementAbsoluteX1(element));\n      subCanvasX2 = Math.max(subCanvasX2, getElementAbsoluteX2(element));\n      subCanvasY1 = Math.min(subCanvasY1, getElementAbsoluteY1(element));\n      subCanvasY2 = Math.max(subCanvasY2, getElementAbsoluteY2(element));\n    });\n\n    // create temporary canvas from which we'll export\n\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCanvasCtx = tempCanvas.getContext(\"2d\")!;\n    tempCanvas.style.display = \"none\";\n    document.body.appendChild(tempCanvas);\n    tempCanvas.width = exportVisibleOnly\n      ? subCanvasX2 - subCanvasX1 + exportPadding * 2\n      : canvas.width;\n    tempCanvas.height = exportVisibleOnly\n      ? subCanvasY2 - subCanvasY1 + exportPadding * 2\n      : canvas.height;\n\n    // if we're exporting without bg, we need to rerender the scene without it\n    //  (it's reset again, below)\n    if (!exportBackground) {\n      renderScene(rc, context, null);\n    }\n\n    // copy our original canvas onto the temp canvas\n    tempCanvasCtx.drawImage(\n      canvas, // source\n      exportVisibleOnly // sx\n        ? subCanvasX1 - exportPadding\n        : 0,\n      exportVisibleOnly // sy\n        ? subCanvasY1 - exportPadding\n        : 0,\n      exportVisibleOnly // sWidth\n        ? subCanvasX2 - subCanvasX1 + exportPadding * 2\n        : canvas.width,\n      exportVisibleOnly // sHeight\n        ? subCanvasY2 - subCanvasY1 + exportPadding * 2\n        : canvas.height,\n      0, // dx\n      0, // dy\n      exportVisibleOnly ? tempCanvas.width : canvas.width, // dWidth\n      exportVisibleOnly ? tempCanvas.height : canvas.height // dHeight\n    );\n\n    // reset transparent bg back to original\n    if (!exportBackground) {\n      renderScene(rc, context, viewBackgroundColor);\n    }\n\n    // create a temporary <a> elem which we'll use to download the image\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"download\", \"excalibur.png\");\n    link.setAttribute(\"href\", tempCanvas.toDataURL(\"image/png\"));\n    link.click();\n\n    // clean up the DOM\n    link.remove();\n    if (tempCanvas !== canvas) tempCanvas.remove();\n  });\n}\n\nfunction rotate(x1: number, y1: number, x2: number, y2: number, angle: number) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nvar generator = rough.generator(null, null as any);\n\nfunction isTextElement(\n  element: ExcaliburElement\n): element is ExcaliburTextElement {\n  return element.type === \"text\";\n}\n\nfunction getArrowPoints(element: ExcaliburElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n\nfunction generateDraw(element: ExcaliburElement) {\n  if (element.type === \"selection\") {\n    element.draw = (rc, context) => {\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(element.x, element.y, element.width, element.height);\n      context.fillStyle = fillStyle;\n    };\n  } else if (element.type === \"rectangle\") {\n    const shape = generator.rectangle(0, 0, element.width, element.height, {\n      stroke: element.strokeColor,\n      fill: element.backgroundColor\n    });\n    element.draw = (rc, context) => {\n      context.translate(element.x, element.y);\n      rc.draw(shape);\n      context.translate(-element.x, -element.y);\n    };\n  } else if (element.type === \"ellipse\") {\n    const shape = generator.ellipse(\n      element.width / 2,\n      element.height / 2,\n      element.width,\n      element.height,\n      { stroke: element.strokeColor, fill: element.backgroundColor }\n    );\n    element.draw = (rc, context) => {\n      context.translate(element.x, element.y);\n      rc.draw(shape);\n      context.translate(-element.x, -element.y);\n    };\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const shapes = [\n      //    \\\n      generator.line(x3, y3, x2, y2, { stroke: element.strokeColor }),\n      // -----\n      generator.line(x1, y1, x2, y2, { stroke: element.strokeColor }),\n      //    /\n      generator.line(x4, y4, x2, y2, { stroke: element.strokeColor })\n    ];\n\n    element.draw = (rc, context) => {\n      context.translate(element.x, element.y);\n      shapes.forEach(shape => rc.draw(shape));\n      context.translate(-element.x, -element.y);\n    };\n    return;\n  } else if (isTextElement(element)) {\n    element.draw = (rc, context) => {\n      const font = context.font;\n      context.font = element.font;\n      const fillStyle = context.fillStyle;\n      context.fillStyle = element.strokeColor;\n      context.fillText(\n        element.text,\n        element.x,\n        element.y + element.actualBoundingBoxAscent\n      );\n      context.fillStyle = fillStyle;\n      context.font = font;\n    };\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nfunction getElementAbsoluteX1(element: ExcaliburElement) {\n  return element.width >= 0 ? element.x : element.x + element.width;\n}\nfunction getElementAbsoluteX2(element: ExcaliburElement) {\n  return element.width >= 0 ? element.x + element.width : element.x;\n}\nfunction getElementAbsoluteY1(element: ExcaliburElement) {\n  return element.height >= 0 ? element.y : element.y + element.height;\n}\nfunction getElementAbsoluteY2(element: ExcaliburElement) {\n  return element.height >= 0 ? element.y + element.height : element.y;\n}\n\nfunction setSelection(selection: ExcaliburElement) {\n  const selectionX1 = getElementAbsoluteX1(selection);\n  const selectionX2 = getElementAbsoluteX2(selection);\n  const selectionY1 = getElementAbsoluteY1(selection);\n  const selectionY2 = getElementAbsoluteY2(selection);\n  elements.forEach(element => {\n    const elementX1 = getElementAbsoluteX1(element);\n    const elementX2 = getElementAbsoluteX2(element);\n    const elementY1 = getElementAbsoluteY1(element);\n    const elementY2 = getElementAbsoluteY2(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nfunction clearSelection() {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nfunction deleteSelectedElements() {\n  for (var i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\ntype AppState = {\n  draggingElement: ExcaliburElement | null;\n  elementType: string;\n  exportBackground: boolean;\n  exportVisibleOnly: boolean;\n  exportPadding: number;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  viewBackgroundColor: string;\n};\n\nconst KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\nfunction isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\n\nclass App extends React.Component<{}, AppState> {\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    elementType: \"selection\",\n    exportBackground: false,\n    exportVisibleOnly: true,\n    exportPadding: 10,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    viewBackgroundColor: \"#ffffff\"\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if ((event.target as HTMLElement).nodeName === \"INPUT\") {\n      return;\n    }\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      deleteSelectedElements();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === \"a\" && event.metaKey) {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    }\n  };\n\n  private renderOption({\n    type,\n    children\n  }: {\n    type: string;\n    children: React.ReactNode;\n  }) {\n    return (\n      <label>\n        <input\n          type=\"radio\"\n          checked={this.state.elementType === type}\n          onChange={() => {\n            this.setState({ elementType: type });\n            clearSelection();\n            this.forceUpdate();\n          }}\n        />\n        {children}\n      </label>\n    );\n  }\n\n  public render() {\n    return (\n      <div\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements();\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          let parsedElements;\n          try {\n            parsedElements = JSON.parse(paste);\n          } catch (e) {}\n          if (\n            Array.isArray(parsedElements) &&\n            parsedElements.length > 0 &&\n            parsedElements[0].type // need to implement a better check here...\n          ) {\n            clearSelection();\n            parsedElements.forEach(parsedElement => {\n              parsedElement.x += 10;\n              parsedElement.y += 10;\n              generateDraw(parsedElement);\n              elements.push(parsedElement);\n            });\n            this.forceUpdate();\n          }\n          e.preventDefault();\n        }}\n      >\n        <fieldset>\n          <legend>Shapes</legend>\n          {this.renderOption({ type: \"rectangle\", children: \"Rectangle\" })}\n          {this.renderOption({ type: \"ellipse\", children: \"Ellipse\" })}\n          {this.renderOption({ type: \"arrow\", children: \"Arrow\" })}\n          {this.renderOption({ type: \"text\", children: \"Text\" })}\n          {this.renderOption({ type: \"selection\", children: \"Selection\" })}\n        </fieldset>\n\n        <canvas\n          id=\"canvas\"\n          width={window.innerWidth}\n          height={window.innerHeight - 200}\n          onMouseDown={e => {\n            const x = e.clientX - (e.target as HTMLElement).offsetLeft;\n            const y = e.clientY - (e.target as HTMLElement).offsetTop;\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor\n            );\n            let isDraggingElements = false;\n            const cursorStyle = document.documentElement.style.cursor;\n            if (this.state.elementType === \"selection\") {\n              const hitElement = elements.find(element => {\n                return hitTest(element, x, y);\n              });\n\n              // If we click on something\n              if (hitElement) {\n                if (hitElement.isSelected) {\n                  // If that element is not already selected, do nothing,\n                  // we're likely going to drag it\n                } else {\n                  // We unselect every other elements unless shift is pressed\n                  if (!e.shiftKey) {\n                    clearSelection();\n                  }\n                  // No matter what, we select it\n                  hitElement.isSelected = true;\n                }\n              } else {\n                // If we don't click on anything, let's remove all the selected elements\n                clearSelection();\n              }\n\n              isDraggingElements = elements.some(element => element.isSelected);\n\n              if (isDraggingElements) {\n                document.documentElement.style.cursor = \"move\";\n              }\n            }\n\n            if (isTextElement(element)) {\n              const text = prompt(\"What text do you want?\");\n              if (text === null) {\n                return;\n              }\n              element.text = text;\n              element.font = \"20px Virgil\";\n              const font = context.font;\n              context.font = element.font;\n              const {\n                actualBoundingBoxAscent,\n                actualBoundingBoxDescent,\n                width\n              } = context.measureText(element.text);\n              element.actualBoundingBoxAscent = actualBoundingBoxAscent;\n              context.font = font;\n              const height = actualBoundingBoxAscent + actualBoundingBoxDescent;\n              // Center the text\n              element.x -= width / 2;\n              element.y -= actualBoundingBoxAscent;\n              element.width = width;\n              element.height = height;\n            }\n\n            generateDraw(element);\n            elements.push(element);\n            if (this.state.elementType === \"text\") {\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              element.isSelected = true;\n            } else {\n              this.setState({ draggingElement: element });\n            }\n\n            let lastX = x;\n            let lastY = y;\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const x = e.clientX - target.offsetLeft;\n                  const y = e.clientY - target.offsetTop;\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width = e.clientX - target.offsetLeft - draggingElement.x;\n              let height = e.clientY - target.offsetTop - draggingElement.y;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey ? width : height;\n\n              generateDraw(draggingElement);\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(draggingElement);\n              }\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              document.documentElement.style.cursor = cursorStyle;\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection();\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            this.forceUpdate();\n          }}\n        />\n        <fieldset>\n          <legend>Colors</legend>\n          <label>\n            <input\n              type=\"color\"\n              value={this.state.viewBackgroundColor}\n              onChange={e => {\n                this.setState({ viewBackgroundColor: e.target.value });\n              }}\n            />\n            Background\n          </label>\n          <label>\n            <input\n              type=\"color\"\n              value={this.state.currentItemStrokeColor}\n              onChange={e => {\n                this.setState({ currentItemStrokeColor: e.target.value });\n              }}\n            />\n            Shape Stroke\n          </label>\n          <label>\n            <input\n              type=\"color\"\n              value={this.state.currentItemBackgroundColor}\n              onChange={e => {\n                this.setState({ currentItemBackgroundColor: e.target.value });\n              }}\n            />\n            Shape Background\n          </label>\n        </fieldset>\n        <fieldset>\n          <legend>Export</legend>\n          <button\n            onClick={() => {\n              exportAsPNG({\n                exportBackground: this.state.exportBackground,\n                exportVisibleOnly: this.state.exportVisibleOnly,\n                exportPadding: this.state.exportPadding,\n                viewBackgroundColor: this.state.viewBackgroundColor\n              });\n            }}\n          >\n            Export to png\n          </button>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={this.state.exportBackground}\n              onChange={e => {\n                this.setState({ exportBackground: e.target.checked });\n              }}\n            />\n            background\n          </label>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={this.state.exportVisibleOnly}\n              onChange={e => {\n                this.setState({ exportVisibleOnly: e.target.checked });\n              }}\n            />\n            visible area only\n          </label>\n          (padding:\n          <input\n            type=\"number\"\n            value={this.state.exportPadding}\n            onChange={e => {\n              this.setState({ exportPadding: Number(e.target.value) });\n            }}\n            disabled={!this.state.exportVisibleOnly}\n          />\n          px)\n        </fieldset>\n      </div>\n    );\n  }\n\n  componentDidUpdate() {\n    renderScene(rc, context, this.state.viewBackgroundColor);\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst rc = rough.canvas(canvas);\nconst context = canvas.getContext(\"2d\")!;\n\n// Big hack to ensure that all the 1px lines are drawn at 1px instead of 2px\n// https://stackoverflow.com/questions/13879322/drawing-a-1px-thick-line-in-canvas-creates-a-2px-thick-line/13879402#comment90766599_13879402\ncontext.translate(0.5, 0.5);\n\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}