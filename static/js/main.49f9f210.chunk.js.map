{"version":3,"sources":["zindex.ts","index.tsx"],"names":["swap","elements","indexA","indexB","element","moveOneLeft","indicesToMove","sort","a","b","isSorted","forEach","index","i","moveOneRight","reversedIndicesToMove","length","moveAllLeft","leftMostElements","map","reverse","concat","pos","moveAllRight","rightMostElements","Array","of","randomSeed","Math","floor","random","withCustomMathRandom","seed","cb","imul","LCG","result","distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","hypot","hitTest","type","px","abs","width","py","height","tx","ty","ex","ey","rx","ry","qx","qy","r","q","min","max","t","getElementAbsoluteX1","getElementAbsoluteX2","getElementAbsoluteY1","getElementAbsoluteY2","getArrowPoints","x3","y3","x4","y4","console","warn","Error","resizeTest","sceneState","handlers","handlerRectangles","filter","Object","keys","key","handler","scrollX","scrollY","getScrollbars","canvasWidth","canvasHeight","scrollBarWidth","horizontalScrollBar","SCROLLBAR_MARGIN","scrollBarHeight","horizontal","vertical","SCROLLBAR_WIDTH","elementX1","elementX2","elementY1","elementY2","marginX","marginY","renderScene","rc","canvas","offsetX","offsetY","renderScrollbars","renderSelection","context","getContext","fillStyle","viewBackgroundColor","fillRect","clearRect","selectedIndices","getSelectedIndices","draw","isSelected","lineDash","getLineDash","setLineDash","strokeRect","margin","values","scrollBars","rotate","angle","cos","sin","generator","rough","isTextElement","isInputLike","target","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","distance","minSize","xs","ys","PI","generateDraw","shape","rectangle","stroke","strokeColor","fill","backgroundColor","translate","ellipse","shapes","line","font","fillText","text","actualBoundingBoxAscent","clearSelection","deleteSelectedElements","splice","KEYS","SHAPES","icon","viewBox","d","value","shapesShortcutKeys","findElementByKey","reduce","isArrowKey","keyCode","push","someElementIsSelected","some","App","state","draggingElement","resizingElement","elementType","exportBackground","currentItemStrokeColor","currentItemBackgroundColor","onResize","forceUpdate","onKeyDown","event","preventDefault","step","shiftKey","metaKey","altKey","code","includes","toLowerCase","setState","clearCanvas","window","confirm","removeWheelEventListener","handleWheel","e","deltaX","deltaY","document","addEventListener","this","savedState","savedElements","localStorage","getItem","JSON","parse","restore","removeEventListener","className","onCut","clipboardData","setData","stringify","onCopy","onPaste","parsedElements","paste","getData","isArray","parsedElement","checked","onChange","onClick","title","exportPadding","alert","subCanvasX1","Infinity","subCanvasX2","subCanvasY1","subCanvasY2","tempCanvas","createElement","style","display","body","appendChild","link","setAttribute","toDataURL","click","remove","exportAsPNG","id","innerWidth","innerHeight","ref","undefined","passive","onMouseDown","button","activeElement","blur","clientX","offsetLeft","clientY","offsetTop","newElement","resizeHandle","isDraggingElements","isResizingElements","cursorStyle","documentElement","cursor","resizeElement","find","hitElement","prompt","measureText","actualBoundingBoxDescent","lastX","lastY","onMouseMove","HTMLElement","el","selectedElements","selection","selectionX1","selectionX2","selectionY1","selectionY2","setSelection","onMouseUp","pop","setItem","React","Component","rootElement","getElementById","ReactDOM","render"],"mappings":"oQAAA,SAASA,EAAQC,EAAeC,EAAgBC,GAC9C,IAAMC,EAAUH,EAASC,GACzBD,EAASC,GAAUD,EAASE,GAC5BF,EAASE,GAAUC,EAGd,SAASC,EAAeJ,EAAeK,GAC5CA,EAAcC,MAAK,SAACC,EAAWC,GAAZ,OAA0BD,EAAIC,KACjD,IAAIC,GAAW,EAEfJ,EAAcK,SAAQ,SAACC,EAAOC,IAG5BH,EAAWA,GAAYE,IAAUC,IAIjCb,EAAKC,EAAUW,EAAQ,EAAGA,MAIvB,SAASE,EAAgBb,EAAeK,GAC7C,IAAMS,EAAwBT,EAAcC,MAC1C,SAACC,EAAWC,GAAZ,OAA0BA,EAAID,KAE5BE,GAAW,EAGfK,EAAsBJ,SAAQ,SAACC,EAAOC,IAGpCH,EAAWA,GAAYE,IAAUX,EAASe,OAASH,EAAI,IAIvDb,EAAKC,EAAUW,EAAQ,EAAGA,MAkDvB,SAASK,EAAehB,EAAeK,GAC5CA,EAAcC,MAAK,SAACC,EAAWC,GAAZ,OAA0BD,EAAIC,KAGjD,IAAMS,EAAmBZ,EAAca,KAAI,SAAAP,GAAK,OAAIX,EAASW,MAEvDG,EAAwBT,EAE3Bc,UAEAC,OAAO,CAAC,IAEXN,EAAsBJ,SAAQ,SAACC,EAAOC,GAEpC,GAAU,IAANA,EAKJ,IAAK,IAAIS,EAAMP,EAAsBF,EAAI,GAAK,EAAGS,GAAOV,IAASU,EAE/DrB,EAASqB,EAAMT,GAAKZ,EAASqB,MAKjCJ,EAAiBP,SAAQ,SAACP,EAASS,GACjCZ,EAASY,GAAKT,KAiDX,SAASmB,EAAgBtB,EAAeK,GAC7C,IAAMS,EAAwBT,EAAcC,MAC1C,SAACC,EAAWC,GAAZ,OAA0BA,EAAID,KAI1BgB,EAAoBT,EAAsBI,KAAI,SAAAP,GAAK,OAAIX,EAASW,OAEtEN,EAAgBS,EAEbK,UAEAC,OAAO,CAACpB,EAASe,UAENL,SAAQ,SAACC,EAAOC,GAE5B,GAAU,IAANA,EAKJ,IAAK,IAAIS,EAAMhB,EAAcO,EAAI,GAAK,EAAGS,EAAMV,IAASU,EAEtDrB,EAASqB,EAAMT,GAAKZ,EAASqB,MAKjCE,EAAkBb,SAAQ,SAACP,EAASS,GAClCZ,EAASA,EAASe,OAASH,EAAI,GAAKT,K,UC1KlCH,EAAWwB,MAAMC,KAMvB,SAASC,IACP,OAAOC,KAAKC,MAAMD,KAAKE,SAALF,KAAA,IAAgB,EAAK,KAMzC,SAASG,EAAwBC,EAAcC,GAC7C,IAAMH,EAASF,KAAKE,OACpBF,KAAKE,OAZK,SAACE,GAAD,OAAkB,kBAC1B,WAAK,IAAK,GAAMA,EAAOJ,KAAKM,KAAK,MAAOF,KAA1C,SAAoD,EAAK,KAW3CG,CAAIH,GAClB,IAAMI,EAASH,IAEf,OADAL,KAAKE,OAASA,EACPM,EAIT,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAaIC,EAAIC,EAXFC,EAAIJ,EAAKF,EACTO,EAAIJ,EAAKF,EAGTO,EAAYF,EAAIA,EAAIC,EAAIA,EAC1BE,GAAS,EACK,IAAdD,IAEFC,IAVQX,EAAIE,GAKEM,GAJNP,EAAIE,GAIUM,GAKRC,GAIZC,EAAQ,GACVL,EAAKJ,EACLK,EAAKJ,GACIQ,EAAQ,GACjBL,EAAKF,EACLG,EAAKF,IAELC,EAAKJ,EAAKS,EAAQH,EAClBD,EAAKJ,EAAKQ,EAAQF,GAGpB,IAAMG,EAAKZ,EAAIM,EACTO,EAAKZ,EAAIM,EACf,OAAOjB,KAAKwB,MAAMF,EAAIC,GAGxB,SAASE,EAAQjD,EAA4BkC,EAAWC,GAKtD,GAAqB,YAAjBnC,EAAQkD,KAAoB,CAE9B,IAAMC,EAAK3B,KAAK4B,IAAIlB,EAAIlC,EAAQkC,EAAIlC,EAAQqD,MAAQ,GAC9CC,EAAK9B,KAAK4B,IAAIjB,EAAInC,EAAQmC,EAAInC,EAAQuD,OAAS,GAEjDC,EAAK,KACLC,EAAK,KAEHrD,EAAIJ,EAAQqD,MAAQ,EACpBhD,EAAIL,EAAQuD,OAAS,EAyB3B,MAvBA,CAAC,EAAG,EAAG,EAAG,GAAGhD,SAAQ,SAAA2B,GACnB,IAAMM,EAAKpC,EAAIoD,EACTf,EAAKpC,EAAIoD,EAETC,GAAOtD,EAAIA,EAAIC,EAAIA,GAAb,SAAkBmD,EAAM,GAAKpD,EACnCuD,GAAOtD,EAAIA,EAAID,EAAIA,GAAb,SAAkBqD,EAAM,GAAKpD,EAEnCuD,EAAKpB,EAAKkB,EACVG,EAAKpB,EAAKkB,EAEVG,EAAKX,EAAKO,EACVK,EAAKT,EAAKK,EAEVK,EAAIxC,KAAKwB,MAAMa,EAAID,GACnBK,EAAIzC,KAAKwB,MAAMe,EAAID,GAEzBN,EAAKhC,KAAK0C,IAAI,EAAG1C,KAAK2C,IAAI,GAAKL,EAAKE,EAAKC,EAAIP,GAAMtD,IACnDqD,EAAKjC,KAAK0C,IAAI,EAAG1C,KAAK2C,IAAI,GAAKJ,EAAKC,EAAKC,EAAIN,GAAMtD,IACnD,IAAM+D,EAAI5C,KAAKwB,MAAMS,EAAID,GACzBA,GAAMY,EACNX,GAAMW,KAGD5C,KAAKwB,MAAM5C,EAAIoD,EAAKL,EAAI9C,EAAIoD,EAAKH,GApCpB,GAqCf,GAAqB,cAAjBtD,EAAQkD,KAAsB,CACvC,IAAMd,EAAKiC,EAAqBrE,GAC1BsC,EAAKgC,EAAqBtE,GAC1BqC,EAAKkC,EAAqBvE,GAC1BuC,EAAKiC,EAAqBxE,GAKhC,OACEiC,EAA+BC,EAAGC,EAAGC,EAAIC,EAAIC,EAAID,GA/C/B,IAgDlBJ,EAA+BC,EAAGC,EAAGG,EAAID,EAAIC,EAAIC,GAhD/B,IAiDlBN,EAA+BC,EAAGC,EAAGG,EAAIC,EAAIH,EAAIG,GAjD/B,IAkDlBN,EAA+BC,EAAGC,EAAGC,EAAIG,EAAIH,EAAIC,GAlD/B,GAoDf,GAAqB,UAAjBrC,EAAQkD,KAAkB,CAAC,IAAD,EACIuB,EAAezE,GADnB,mBAC9BoC,EAD8B,KAC1BC,EAD0B,KACtBC,EADsB,KAClBC,EADkB,KACdmC,EADc,KACVC,EADU,KACNC,EADM,KACFC,EADE,KAMnC,OAEE5C,EALFC,GAAKlC,EAAQkC,EACbC,GAAKnC,EAAQmC,EAI0BuC,EAAIC,EAAIrC,EAAIC,GA5D/B,IA8DlBN,EAA+BC,EAAGC,EAAGC,EAAIC,EAAIC,EAAIC,GA9D/B,IAgElBN,EAA+BC,EAAGC,EAAGyC,EAAIC,EAAIvC,EAAIC,GAhE/B,GAkEf,GAAqB,SAAjBvC,EAAQkD,KAAiB,CAClC,IAAMd,EAAKiC,EAAqBrE,GAC1BsC,EAAKgC,EAAqBtE,GAC1BqC,EAAKkC,EAAqBvE,GAC1BuC,EAAKiC,EAAqBxE,GAEhC,OAAOkC,GAAKE,GAAMF,GAAKI,GAAMH,GAAKE,GAAMF,GAAKI,EACxC,GAAqB,cAAjBvC,EAAQkD,KAEjB,OADA4B,QAAQC,KAAK,gEACN,EAEP,MAAM,IAAIC,MAAM,sBAAwBhF,EAAQkD,MAIpD,SAAS+B,EACPjF,EACAkC,EACAC,EACA+C,GAEA,GAAqB,SAAjBlF,EAAQkD,MAAoC,UAAjBlD,EAAQkD,KAAkB,OAAO,EAEhE,IAAMiC,EAAWC,EAAkBpF,EAASkF,GAEtCG,EAASC,OAAOC,KAAKJ,GAAUE,QAAO,SAAAG,GAC1C,IAAMC,EAAUN,EAASK,GAEzB,OACEtD,EAAIgD,EAAWQ,SAAWD,EAAQ,IAClCvD,EAAIgD,EAAWQ,SAAWD,EAAQ,GAAKA,EAAQ,IAC/CtD,EAAI+C,EAAWS,SAAWF,EAAQ,IAClCtD,EAAI+C,EAAWS,SAAWF,EAAQ,GAAKA,EAAQ,MAInD,OAAIJ,EAAOzE,OAAS,GACXyE,EAAO,GA+ClB,SAASO,EACPC,EACAC,EACAJ,EACAC,GAGA,IACMI,EAAkBF,EAAcA,GADnBA,EAAcrE,KAAK4B,IAAIsC,IAGpCM,EAAsB,CAC1B9D,GAFiBwD,EAAU,EAAI,EAAIG,EAAcE,GAd5B,EAiBrB5D,EAAG2D,EAlBiB,EACC,EAkBrBzC,MAAO0C,EAAiBE,EACxB1C,OApBoB,GAyBhB2C,EAAmBJ,EAAeA,GADpBA,EAAetE,KAAK4B,IAAIuC,IAU5C,MAAO,CACLQ,WAAYH,EACZI,SATwB,CACxBlE,EAAG2D,EA5BiB,EACC,EA4BrB1D,GAHiBwD,EAAU,EAAI,EAAIG,EAAeI,GAzB7B,EA6BrB7C,MA9BoB,EA+BpBE,OAAQ2C,EAAkBG,KAS9B,SAASjB,EAAkBpF,EAA4BkF,GACrD,IAAMoB,EAAYtG,EAAQkC,EACpBqE,EAAYvG,EAAQkC,EAAIlC,EAAQqD,MAChCmD,EAAYxG,EAAQmC,EACpBsE,EAAYzG,EAAQmC,EAAInC,EAAQuD,OAIhC4B,EAA4C,GAE5CuB,EAAU1G,EAAQqD,MAAQ,EAAI,GAAK,EACnCsD,EAAU3G,EAAQuD,OAAS,EAAI,GAAK,EA2D1C,OAzDI/B,KAAK4B,IAAImD,EAAYD,GANL,KAOlBnB,EAAQ,EAAQ,CACdmB,GAAaC,EAAYD,GAAa,EAAIpB,EAAWQ,QAAU,EAC/Dc,EAVW,EAUUtB,EAAWS,QAAUgB,EAC1C,EACA,GAGFxB,EAAQ,EAAQ,CACdmB,GAAaC,EAAYD,GAAa,EAAIpB,EAAWQ,QAAU,EAC/De,EAjBW,EAiBUvB,EAAWS,QAAUgB,EAC1C,EACA,IAIAnF,KAAK4B,IAAIqD,EAAYD,GAtBL,KAuBlBrB,EAAQ,EAAQ,CACdmB,EAzBW,EAyBUpB,EAAWQ,QAAUgB,EAC1CF,GAAaC,EAAYD,GAAa,EAAItB,EAAWS,QAAU,EAC/D,EACA,GAGFR,EAAQ,EAAQ,CACdoB,EAhCW,EAgCUrB,EAAWQ,QAAUgB,EAC1CF,GAAaC,EAAYD,GAAa,EAAItB,EAAWS,QAAU,EAC/D,EACA,IAIJR,EAAQ,GAAS,CACfmB,EAxCa,EAwCQpB,EAAWQ,QAAUgB,EAC1CF,EAzCa,EAyCQtB,EAAWS,QAAUgB,EAC1C,EACA,GAEFxB,EAAQ,GAAS,CACfoB,EA9Ca,EA8CQrB,EAAWQ,QAAUgB,EAC1CF,EA/Ca,EA+CQtB,EAAWS,QAAUgB,EAC1C,EACA,GAEFxB,EAAQ,GAAS,CACfmB,EApDa,EAoDQpB,EAAWQ,QAAUgB,EAC1CD,EArDa,EAqDQvB,EAAWS,QAAUgB,EAC1C,EACA,GAEFxB,EAAQ,GAAS,CACfoB,EA1Da,EA0DQrB,EAAWQ,QAAUgB,EAC1CD,EA3Da,EA2DQvB,EAAWS,QAAUgB,EAC1C,EACA,GAGKxB,EAGT,SAASyB,EACPC,EACAC,EACA5B,GAaC,IAAD,yDADI,GATF6B,EAUF,EAVEA,QACAC,EASF,EATEA,QASF,IAREC,wBAQF,aAPEC,uBAOF,SACA,GAAKJ,EAAL,CACA,IAAMK,EAAUL,EAAOM,WAAW,MAE5BC,EAAYF,EAAQE,UACoB,kBAAnCnC,EAAWoC,qBACpBH,EAAQE,UAAYnC,EAAWoC,oBAC/BH,EAAQI,UAAU,IAAM,GAAKT,EAAOzD,MAAOyD,EAAOvD,SAElD4D,EAAQK,WAAW,IAAM,GAAKV,EAAOzD,MAAOyD,EAAOvD,QAErD4D,EAAQE,UAAYA,EAEpB,IAAMI,EAAkBC,IAwCxB,GAtCAxC,EAAU,eACLA,EADK,CAERQ,QAA4B,kBAAZqB,EAAuBA,EAAU7B,EAAWQ,QAC5DC,QAA4B,kBAAZqB,EAAuBA,EAAU9B,EAAWS,UAG9D9F,EAASU,SAAQ,SAAAP,GAEf,GADAA,EAAQ2H,KAAKd,EAAIM,EAASjC,GACtBgC,GAAmBlH,EAAQ4H,WAAY,CACzC,IAEMtB,EAAYjC,EAAqBrE,GACjCuG,EAAYjC,EAAqBtE,GACjCwG,EAAYjC,EAAqBvE,GACjCyG,EAAYjC,EAAqBxE,GACjC6H,EAAWV,EAAQW,cAUzB,GATAX,EAAQY,YAAY,CAAC,EAAG,IACxBZ,EAAQa,WACN1B,EATa,EASQpB,EAAWQ,QAChCc,EAVa,EAUQtB,EAAWS,QAChCY,EAAYD,EAAY2B,EACxBxB,EAAYD,EAAYyB,GAE1Bd,EAAQY,YAAYF,GAGD,SAAjB7H,EAAQkD,MACS,UAAjBlD,EAAQkD,MACmB,IAA3BuE,EAAgB7G,OAChB,CACA,IAAMuE,EAAWC,EAAkBpF,EAASkF,GAC5CI,OAAO4C,OAAO/C,GAAU5E,SAAQ,SAAAkF,GAC9B0B,EAAQa,WAAWvC,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,YAMnEwB,EAAkB,CACpB,IAAMkB,EAAavC,EACjBuB,EAAQL,OAAOzD,MACf8D,EAAQL,OAAOvD,OACf2B,EAAWQ,QACXR,EAAWS,SAGbwB,EAAQE,UA5LY,kBA6LpBF,EAAQI,SACNY,EAAWhC,WAAWjE,EACtBiG,EAAWhC,WAAWhE,EACtBgG,EAAWhC,WAAW9C,MACtB8E,EAAWhC,WAAW5C,QAExB4D,EAAQI,SACNY,EAAW/B,SAASlE,EACpBiG,EAAW/B,SAASjE,EACpBgG,EAAW/B,SAAS/C,MACpB8E,EAAW/B,SAAS7C,QAEtB4D,EAAQE,UAAYA,IAoExB,SAASe,EAAOhG,EAAYC,EAAYC,EAAYC,EAAY8F,GAI9D,MAAO,EACJjG,EAAKE,GAAMd,KAAK8G,IAAID,IAAUhG,EAAKE,GAAMf,KAAK+G,IAAIF,GAAS/F,GAC3DF,EAAKE,GAAMd,KAAK+G,IAAIF,IAAUhG,EAAKE,GAAMf,KAAK8G,IAAID,GAAS9F,GAMhE,IAAMiG,EAAYC,IAAMD,UAAU,KAAM,MAExC,SAASE,EACP1I,GAEA,MAAwB,SAAjBA,EAAQkD,KAGjB,SAASyF,EACPC,GAEA,OACEA,aAAkBC,kBAClBD,aAAkBE,qBAClBF,aAAkBG,kBAItB,SAAStE,EAAezE,GACtB,IAEMsC,EAAKtC,EAAQqD,MACbd,EAAKvC,EAAQuD,OAGbyF,EAAWxH,KAAKwB,MAAMV,EANjB,EAM0BC,EAL1B,GAOL0G,EAAUzH,KAAK0C,IAHR,GAGkB8E,EAAW,GACpCE,EAAK5G,GAAOA,EATP,GASkB0G,EAAYC,EACnCE,EAAK5G,GAAOA,EATP,GASkByG,EAAYC,EAXS,EAcjCb,EAAOc,EAAIC,EAAI7G,EAAIC,GADtB,GACoCf,KAAK4H,GAAM,KAdX,mBAc3C1E,EAd2C,KAcvCC,EAduC,OAejCyD,EAAOc,EAAIC,EAAI7G,EAAIC,EAFtB,GAEmCf,KAAK4H,GAAM,KAfV,mBAiBlD,MAAO,CAhBI,EACA,EAeK9G,EAAIC,EAAImC,EAAIC,EAjBsB,WAoBpD,SAAS0E,EAAarJ,GACpB,GAAqB,cAAjBA,EAAQkD,KACVlD,EAAQ2H,KAAO,SAACd,EAAIM,EAAL,GAAwC,IAAxBzB,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QAChC0B,EAAYF,EAAQE,UAC1BF,EAAQE,UAAY,wBACpBF,EAAQI,SACNvH,EAAQkC,EAAIwD,EACZ1F,EAAQmC,EAAIwD,EACZ3F,EAAQqD,MACRrD,EAAQuD,QAEV4D,EAAQE,UAAYA,QAEjB,GAAqB,cAAjBrH,EAAQkD,KAAsB,CACvC,IAAMoG,EAAQ3H,EAAqB3B,EAAQ4B,MAAM,WAC/C,OAAO4G,EAAUe,UAAU,EAAG,EAAGvJ,EAAQqD,MAAOrD,EAAQuD,OAAQ,CAC9DiG,OAAQxJ,EAAQyJ,YAChBC,KAAM1J,EAAQ2J,qBAGlB3J,EAAQ2H,KAAO,SAACd,EAAIM,EAAL,GAAwC,IAAxBzB,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QACtCwB,EAAQyC,UAAU5J,EAAQkC,EAAIwD,EAAS1F,EAAQmC,EAAIwD,GACnDkB,EAAGc,KAAK2B,GACRnC,EAAQyC,WAAW5J,EAAQkC,EAAIwD,GAAU1F,EAAQmC,EAAIwD,SAElD,GAAqB,YAAjB3F,EAAQkD,KAAoB,CACrC,IAAMoG,EAAQ3H,EAAqB3B,EAAQ4B,MAAM,kBAC/C4G,EAAUqB,QACR7J,EAAQqD,MAAQ,EAChBrD,EAAQuD,OAAS,EACjBvD,EAAQqD,MACRrD,EAAQuD,OACR,CAAEiG,OAAQxJ,EAAQyJ,YAAaC,KAAM1J,EAAQ2J,qBAGjD3J,EAAQ2H,KAAO,SAACd,EAAIM,EAAL,GAAwC,IAAxBzB,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QACtCwB,EAAQyC,UAAU5J,EAAQkC,EAAIwD,EAAS1F,EAAQmC,EAAIwD,GACnDkB,EAAGc,KAAK2B,GACRnC,EAAQyC,WAAW5J,EAAQkC,EAAIwD,GAAU1F,EAAQmC,EAAIwD,QAElD,IAAqB,UAAjB3F,EAAQkD,KAAkB,CAAC,IAAD,EACMuB,EAAezE,GADrB,mBAC5BoC,EAD4B,KACxBC,EADwB,KACpBC,EADoB,KAChBC,EADgB,KACZmC,EADY,KACRC,EADQ,KACJC,EADI,KACAC,EADA,KAE7BiF,EAASnI,EAAqB3B,EAAQ4B,MAAM,iBAAM,CAEtD4G,EAAUuB,KAAKrF,EAAIC,EAAIrC,EAAIC,EAAI,CAAEiH,OAAQxJ,EAAQyJ,cAEjDjB,EAAUuB,KAAK3H,EAAIC,EAAIC,EAAIC,EAAI,CAAEiH,OAAQxJ,EAAQyJ,cAEjDjB,EAAUuB,KAAKnF,EAAIC,EAAIvC,EAAIC,EAAI,CAAEiH,OAAQxJ,EAAQyJ,kBAQnD,YALAzJ,EAAQ2H,KAAO,SAACd,EAAIM,EAAL,GAAwC,IAAxBzB,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QACtCwB,EAAQyC,UAAU5J,EAAQkC,EAAIwD,EAAS1F,EAAQmC,EAAIwD,GACnDmE,EAAOvJ,SAAQ,SAAA+I,GAAK,OAAIzC,EAAGc,KAAK2B,MAChCnC,EAAQyC,WAAW5J,EAAQkC,EAAIwD,GAAU1F,EAAQmC,EAAIwD,KAGlD,IAAI+C,EAAc1I,GAevB,MAAM,IAAIgF,MAAM,sBAAwBhF,EAAQkD,MAdhDlD,EAAQ2H,KAAO,SAACd,EAAIM,EAAL,GAAwC,IAAxBzB,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QAChCqE,EAAO7C,EAAQ6C,KACrB7C,EAAQ6C,KAAOhK,EAAQgK,KACvB,IAAM3C,EAAYF,EAAQE,UAC1BF,EAAQE,UAAYrH,EAAQyJ,YAC5BtC,EAAQ8C,SACNjK,EAAQkK,KACRlK,EAAQkC,EAAIwD,EACZ1F,EAAQmC,EAAInC,EAAQmK,wBAA0BxE,GAEhDwB,EAAQE,UAAYA,EACpBF,EAAQ6C,KAAOA,IAWrB,SAAS3F,EAAqBrE,GAC5B,OAAOA,EAAQqD,OAAS,EAAIrD,EAAQkC,EAAIlC,EAAQkC,EAAIlC,EAAQqD,MAE9D,SAASiB,EAAqBtE,GAC5B,OAAOA,EAAQqD,OAAS,EAAIrD,EAAQkC,EAAIlC,EAAQqD,MAAQrD,EAAQkC,EAElE,SAASqC,EAAqBvE,GAC5B,OAAOA,EAAQuD,QAAU,EAAIvD,EAAQmC,EAAInC,EAAQmC,EAAInC,EAAQuD,OAE/D,SAASiB,EAAqBxE,GAC5B,OAAOA,EAAQuD,QAAU,EAAIvD,EAAQmC,EAAInC,EAAQuD,OAASvD,EAAQmC,EAsBpE,SAASiI,IACPvK,EAASU,SAAQ,SAAAP,GACfA,EAAQ4H,YAAa,KAIzB,SAASyC,IACP,IAAK,IAAI5J,EAAIZ,EAASe,OAAS,EAAGH,GAAK,IAAKA,EACtCZ,EAASY,GAAGmH,YACd/H,EAASyK,OAAO7J,EAAG,GAuCzB,IAAM8J,EACQ,YADRA,EAES,aAFTA,EAGQ,YAHRA,EAIM,UAJNA,EAKI,SALJA,EAMI,SANJA,EAOO,YAIPC,EAAS,CACb,CACEC,KAEE,yBAAKC,QAAQ,eACX,0BAAMC,EAAE,oSAGZC,MAAO,aAET,CACEH,KAEE,yBAAKC,QAAQ,eACX,0BAAMC,EAAE,+GAGZC,MAAO,aAET,CACEH,KAEE,yBAAKC,QAAQ,eACX,0BAAMC,EAAE,2EAGZC,MAAO,WAET,CACEH,KAEE,yBAAKC,QAAQ,eACX,0BAAMC,EAAE,wOAGZC,MAAO,SAET,CACEH,KAEE,yBAAKC,QAAQ,eACX,0BAAMC,EAAE,8UAGZC,MAAO,SAILC,EAAqBL,EAAOzJ,KAAI,SAAAuI,GAAK,OAAIA,EAAMsB,MAAM,MAE3D,SAASE,EAAiBtF,GAExB,OAAOgF,EAAOO,QAAO,SAAC/K,EAASsJ,GAC7B,OAAIA,EAAMsB,MAAM,KAAOpF,EAAYxF,EAE5BsJ,EAAMsB,QAJQ,aAQzB,SAASI,EAAWC,GAClB,OACEA,IAAYV,GACZU,IAAYV,GACZU,IAAYV,GACZU,IAAYV,EAIhB,SAAS7C,IACP,IAAMD,EAA4B,GAMlC,OALA5H,EAASU,SAAQ,SAACP,EAASQ,GACrBR,EAAQ4H,YACVH,EAAgByD,KAAK1K,MAGlBiH,EAGT,IAAM0D,GAAwB,kBAC5BtL,EAASuL,MAAK,SAAApL,GAAO,OAAIA,EAAQ4H,eAK7ByD,G,2MAgBGC,MAAkB,CACvBC,gBAAiB,KACjBC,gBAAiB,KACjBC,YAAa,YACbC,kBAAkB,EAClBC,uBAAwB,UACxBC,2BAA4B,UAC5BtE,oBAAqB,UACrB5B,QAAS,EACTC,QAAS,G,EAGHkG,SAAW,WACjB,EAAKC,e,EAGCC,UAAY,SAACC,GACnB,IAAIrD,EAAYqD,EAAMpD,QAEtB,GAAIoD,EAAMxG,MAAQ+E,EAChBH,IACA,EAAK0B,cACLE,EAAMC,sBACD,GAAID,EAAMxG,MAAQ+E,GAAkByB,EAAMxG,MAAQ+E,EACvDF,IACA,EAAKyB,cACLE,EAAMC,sBACD,GAAIjB,EAAWgB,EAAMxG,KAAM,CAChC,IAAM0G,EAAOF,EAAMG,SA/Cc,EACN,EAiD3BtM,EAASU,SAAQ,SAAAP,GACXA,EAAQ4H,aACNoE,EAAMxG,MAAQ+E,EAAiBvK,EAAQkC,GAAKgK,EACvCF,EAAMxG,MAAQ+E,EAAkBvK,EAAQkC,GAAKgK,EAC7CF,EAAMxG,MAAQ+E,EAAevK,EAAQmC,GAAK+J,EAC1CF,EAAMxG,MAAQ+E,IAAiBvK,EAAQmC,GAAK+J,OAGzD,EAAKJ,cACLE,EAAMC,sBAIND,EAAMI,SACNJ,EAAMG,UACNH,EAAMK,QACS,SAAfL,EAAMM,MAEN,EAAKrM,cACL+L,EAAMC,kBAGGD,EAAMI,SAAWJ,EAAMG,UAA2B,SAAfH,EAAMM,MAClD,EAAKzL,cACLmL,EAAMC,kBAIND,EAAMI,SACNJ,EAAMG,UACNH,EAAMK,QACS,SAAfL,EAAMM,MAEN,EAAK5L,eACLsL,EAAMC,kBAGGD,EAAMI,SAAWJ,EAAMG,UAA2B,SAAfH,EAAMM,MAClD,EAAKnL,eACL6K,EAAMC,kBAGGD,EAAMI,SAA0B,SAAfJ,EAAMM,MAChCzM,EAASU,SAAQ,SAAAP,GACfA,EAAQ4H,YAAa,KAEvB,EAAKkE,cACLE,EAAMC,kBACGpB,EAAmB0B,SAASP,EAAMxG,IAAIgH,gBAC/C,EAAKC,SAAS,CAAEhB,YAAaX,EAAiBkB,EAAMxG,Q,EAIhD6E,uBAAyB,WAC/BA,IACA,EAAKyB,e,EAGCY,YAAc,WAChBC,OAAOC,QAAQ,qDACjB/M,EAASyK,OAAO,EAAGzK,EAASe,QAC5B,EAAK6L,SAAS,CACZnF,oBAAqB,UACrB5B,QAAS,EACTC,QAAS,IAEX,EAAKmG,gB,EAIDjL,YAAc,WACpBA,EAAYhB,EAAU6H,KACtB,EAAKoE,e,EAGC7L,YAAc,WACpBA,EAAYJ,EAAU6H,KACtB,EAAKoE,e,EAGC3K,aAAe,WACrBA,EAAatB,EAAU6H,KACvB,EAAKoE,e,EAGCpL,aAAe,WACrBA,EAAab,EAAU6H,KACvB,EAAKoE,e,EAGCe,8B,IAibAC,YAAc,SAACC,GACrBA,EAAEd,iBADqC,IAE/Be,EAAmBD,EAAnBC,OAAQC,EAAWF,EAAXE,OAChB,EAAKR,UAAS,SAAAnB,GAAK,MAAK,CACtB5F,QAAS4F,EAAM5F,QAAUsH,EACzBrH,QAAS2F,EAAM3F,QAAUsH,O,mFA7jB3BC,SAASC,iBAAiB,UAAWC,KAAKrB,WAAW,GACrDY,OAAOQ,iBAAiB,SAAUC,KAAKvB,UAAU,GAEjD,IAAMwB,EAjIV,WACE,IACE,IAAMC,EAAgBC,aAAaC,QAxpBb,cAypBhBH,EAAaE,aAAaC,QAxpBJ,oBA+pB5B,OALIF,IACFzN,EAASyK,OAAT,MAAAzK,EAAQ,CAAQ,EAAGA,EAASe,QAApB,mBAA+B6M,KAAKC,MAAMJ,MAClDzN,EAASU,SAAQ,SAACP,GAAD,OAAgCqJ,EAAarJ,OAGzDqN,EAAaI,KAAKC,MAAML,GAAc,KAC7C,MAAON,GAEP,OADAlN,EAASyK,OAAO,EAAGzK,EAASe,QACrB,MAoHY+M,GACfN,GACFD,KAAKX,SAASY,K,6CAKhBH,SAASU,oBAAoB,UAAWR,KAAKrB,WAAW,GACxDY,OAAOiB,oBAAoB,SAAUR,KAAKvB,UAAU,K,+BA8HrC,IAAD,OACd,OACE,yBACEgC,UAAU,YACVC,MAAO,SAAAf,GACLA,EAAEgB,cAAcC,QACd,aACAP,KAAKQ,UAAUpO,EAASwF,QAAO,SAAArF,GAAO,OAAIA,EAAQ4H,gBAEpDyC,IACA,EAAKyB,cACLiB,EAAEd,kBAEJiC,OAAQ,SAAAnB,GACNA,EAAEgB,cAAcC,QACd,aACAP,KAAKQ,UAAUpO,EAASwF,QAAO,SAAArF,GAAO,OAAIA,EAAQ4H,gBAEpDmF,EAAEd,kBAEJkC,QAAS,SAAApB,GACP,IACIqB,EADEC,EAAQtB,EAAEgB,cAAcO,QAAQ,QAEtC,IACEF,EAAiBX,KAAKC,MAAMW,GAC5B,MAAOtB,IAEP1L,MAAMkN,QAAQH,IACdA,EAAexN,OAAS,GACxBwN,EAAe,GAAGlL,OAElBkH,IACAgE,EAAe7N,SAAQ,SAAAiO,GACrBA,EAActM,GAAK,GACnBsM,EAAcrM,GAAK,GACnBqM,EAAc5M,KAAOL,IACrB8H,EAAamF,GACb3O,EAASqL,KAAKsD,MAEhB,EAAK1C,eAEPiB,EAAEd,mBAGJ,yBAAK4B,UAAU,aACb,sCACA,yBAAKA,UAAU,cACZrD,EAAOzJ,KAAI,gBAAG6J,EAAH,EAAGA,MAAOH,EAAV,EAAUA,KAAV,OACV,2BAAOjF,IAAKoF,EAAOiD,UAAU,QAC3B,2BACE3K,KAAK,QACLuL,QAAS,EAAKnD,MAAMG,cAAgBb,EACpC8D,SAAU,WACR,EAAKjC,SAAS,CAAEhB,YAAab,IAC7BR,IACA,EAAK0B,iBAGT,yBAAK+B,UAAU,YAAYpD,QAIjC,sCACA,yBAAKoD,UAAU,eACb,+BACE,2BACE3K,KAAK,QACL0H,MAAOwC,KAAK9B,MAAMhE,oBAClBoH,SAAU,SAAA3B,GACR,EAAKN,SAAS,CAAEnF,oBAAqByF,EAAEnE,OAAOgC,WALpD,cAUA,+BACE,2BACE1H,KAAK,QACL0H,MAAOwC,KAAK9B,MAAMK,uBAClB+C,SAAU,SAAA3B,GACR,EAAKN,SAAS,CAAEd,uBAAwBoB,EAAEnE,OAAOgC,WALvD,gBAUA,+BACE,2BACE1H,KAAK,QACL0H,MAAOwC,KAAK9B,MAAMM,2BAClB8C,SAAU,SAAA3B,GACR,EAAKN,SAAS,CAAEb,2BAA4BmB,EAAEnE,OAAOgC,WAL3D,qBAWF,sCACA,yBAAKiD,UAAU,eACb,4BACEc,QAASvB,KAAKV,YACdkC,MAAM,6CAFR,iBAOF,sCACA,yBAAKf,UAAU,eACb,4BACEc,QAAS,YAvmBvB,YAUI,IATFjD,EASC,EATDA,iBASC,IARDmD,qBAQC,MARe,GAQf,EAPDvH,EAOC,EAPDA,oBAQA,IAAKzH,EAASe,OAAQ,OAAO+L,OAAOmC,MAAM,+BAI1C,IAAIC,EAAcC,IACdC,EAAc,EACdC,EAAcF,IACdG,EAAc,EASlB,SAASnG,EAAS9G,EAAWC,GAC3B,OAAOX,KAAK4B,IAAIlB,EAAIC,EAAID,EAAIC,EAAIA,EAAID,GARtCrC,EAASU,SAAQ,SAAAP,GACf+O,EAAcvN,KAAK0C,IAAI6K,EAAa1K,EAAqBrE,IACzDiP,EAAczN,KAAK2C,IAAI8K,EAAa3K,EAAqBtE,IACzDkP,EAAc1N,KAAK0C,IAAIgL,EAAa3K,EAAqBvE,IACzDmP,EAAc3N,KAAK2C,IAAIgL,EAAa3K,EAAqBxE,OAO3D,IAAMoP,EAAalC,SAASmC,cAAc,UAC1CD,EAAWE,MAAMC,QAAU,OAC3BrC,SAASsC,KAAKC,YAAYL,GAC1BA,EAAW/L,MAAQ2F,EAAS+F,EAAaE,GAA+B,EAAhBJ,EACxDO,EAAW7L,OAASyF,EAASkG,EAAaC,GAA+B,EAAhBN,EAEzDjI,EACE6B,IAAM3B,OAAOsI,GACbA,EACA,CACE9H,oBAAqBoE,EAAmBpE,EAAsB,KAC9D5B,QAAS,EACTC,QAAS,GAEX,CACEoB,SAAUgI,EAAcF,EACxB7H,SAAUkI,EAAcL,EACxB5H,kBAAkB,EAClBC,iBAAiB,IAKrB,IAAMwI,EAAOxC,SAASmC,cAAc,KACpCK,EAAKC,aAAa,WAAY,kBAC9BD,EAAKC,aAAa,OAAQP,EAAWQ,UAAU,cAC/CF,EAAKG,QAGLH,EAAKI,SACDV,IAAetI,IAAQsI,EAAWU,SA2iBxBC,CAAY,EAAKzE,SAFrB,iBAOA,+BACE,2BACEpI,KAAK,WACLuL,QAASrB,KAAK9B,MAAMI,iBACpBgD,SAAU,SAAA3B,GACR,EAAKN,SAAS,CAAEf,iBAAkBqB,EAAEnE,OAAO6F,aALjD,eAWDtD,MACC,oCACE,6CACA,yBAAK0C,UAAU,eACb,4BAAQc,QAASvB,KAAK/C,wBAAtB,UACA,4BAAQsE,QAASvB,KAAK1M,cAAtB,iBACA,4BAAQiO,QAASvB,KAAKjM,cAAtB,kBACA,4BAAQwN,QAASvB,KAAKnN,aAAtB,iBACA,4BAAQ0O,QAASvB,KAAKvM,aAAtB,mBAKR,4BACEmP,GAAG,SACH3M,MAAOsJ,OAAOsD,WAn1BU,IAo1BxB1M,OAAQoJ,OAAOuD,YAn1BQ,EAo1BvBC,IAAK,SAAArJ,GACC,EAAK+F,2BACP,EAAKA,2BACL,EAAKA,8BAA2BuD,GAE9BtJ,IACFA,EAAOqG,iBAAiB,QAAS,EAAKL,YAAa,CACjDuD,SAAS,IAEX,EAAKxD,yBAA2B,kBAC9B/F,EAAO8G,oBAAoB,QAAS,EAAKd,gBAG/CwD,YAAa,SAAAvD,GAEX,GAAiB,IAAbA,EAAEwD,OAAN,CAEAxD,EAAEd,iBAIEtD,EAAYuE,SAASsD,gBACvBtD,SAASsD,cAAcC,OAGzB,IAAMvO,EACJ6K,EAAE2D,QACD3D,EAAEnE,OAAuB+H,WAC1B,EAAKrF,MAAM5F,QACPvD,EACJ4K,EAAE6D,QACD7D,EAAEnE,OAAuBiI,UAC1B,EAAKvF,MAAM3F,QACP3F,EA55BlB,SACEkD,EACAhB,EACAC,EACAsH,EACAE,GAGC,IAFDtG,EAEA,uDAFQ,EACRE,EACA,uDADS,EAEHvD,EAAU,CACdkD,KAAMA,EACNhB,EAAGA,EACHC,EAAGA,EACHkB,MAAOA,EACPE,OAAQA,EACRqE,YAAY,EACZ6B,YAAaA,EACbE,gBAAiBA,EACjB/H,KAAML,IACNoG,KAVc,SAWZd,EACAM,EACAjC,MAGJ,OAAOlF,EAm4BmB8Q,CACd,EAAKxF,MAAMG,YACXvJ,EACAC,EACA,EAAKmJ,MAAMK,uBACX,EAAKL,MAAMM,4BAETmF,GAA+B,EAC/BC,GAAqB,EACrBC,GAAqB,EACnBC,EAAchE,SAASiE,gBAAgB7B,MAAM8B,OACnD,GAA+B,cAA3B,EAAK9F,MAAMG,YAA6B,CAC1C,IAAM4F,EAAgBxR,EAASyR,MAAK,SAAAtR,GAClC,OAAOiF,EAAWjF,EAASkC,EAAGC,EAAG,CAC/BuD,QAAS,EAAK4F,MAAM5F,QACpBC,QAAS,EAAK2F,MAAM3F,QACpB2B,oBAAqB,EAAKgE,MAAMhE,yBAQpC,GAJA,EAAKmF,SAAS,CACZjB,gBAAiB6F,GAAgC,OAG/CA,EACFN,EAAe9L,EAAWoM,EAAenP,EAAGC,EAAG,CAC7CuD,QAAS,EAAK4F,MAAM5F,QACpBC,QAAS,EAAK2F,MAAM3F,QACpB2B,oBAAqB,EAAKgE,MAAMhE,sBAElC4F,SAASiE,gBAAgB7B,MAAM8B,OAA/B,UAA2CL,EAA3C,WACAE,GAAqB,MAChB,CAGL,IAFA,IAAIM,EAAa,KAER9Q,EAAIZ,EAASe,OAAS,EAAGH,GAAK,IAAKA,EAC1C,GAAIwC,EAAQpD,EAASY,GAAIyB,EAAGC,GAAI,CAC9BoP,EAAa1R,EAASY,GACtB,MAKA8Q,EACEA,EAAW3J,aAKRmF,EAAEZ,UACL/B,IAGFmH,EAAW3J,YAAa,GAI1BwC,KAGF4G,EAAqB7F,QAGnB+B,SAASiE,gBAAgB7B,MAAM8B,OAAS,SAK9C,GAAI1I,EAAc1I,GAAU,CAC1B,IAAMkK,EAAOsH,OAAO,0BACpB,GAAa,OAATtH,EACF,OAEFlK,EAAQkK,KAAOA,EACflK,EAAQgK,KAAO,cACf,IAAMA,EAAO7C,GAAQ6C,KACrB7C,GAAQ6C,KAAOhK,EAAQgK,KARG,MAatB7C,GAAQsK,YAAYzR,EAAQkK,MAH9BC,EAVwB,EAUxBA,wBACAuH,EAXwB,EAWxBA,yBACArO,EAZwB,EAYxBA,MAEFrD,EAAQmK,wBAA0BA,EAClChD,GAAQ6C,KAAOA,EACf,IAAMzG,EAAS4G,EAA0BuH,EAEzC1R,EAAQkC,GAAKmB,EAAQ,EACrBrD,EAAQmC,GAAKgI,EACbnK,EAAQqD,MAAQA,EAChBrD,EAAQuD,OAASA,EAGnB8F,EAAarJ,GACbH,EAASqL,KAAKlL,GACiB,SAA3B,EAAKsL,MAAMG,aACb,EAAKgB,SAAS,CACZlB,gBAAiB,KACjBE,YAAa,cAEfzL,EAAQ4H,YAAa,GAErB,EAAK6E,SAAS,CAAElB,gBAAiBvL,IAGnC,IAAI2R,EAAQzP,EACR0P,EAAQzP,EAEN0P,EAAc,SAAC9E,GACnB,IAAMnE,EAASmE,EAAEnE,OACjB,GAAMA,aAAkBkJ,YAAxB,CAIA,GAAIb,GAAsB,EAAK3F,MAAME,gBAAiB,CACpD,IAAMuG,EAAK,EAAKzG,MAAME,gBAChBwG,EAAmBnS,EAASwF,QAAO,SAAA0M,GAAE,OAAIA,EAAGnK,cAClD,GAAgC,IAA5BoK,EAAiBpR,OAAc,CACjC,IAAMsB,EACJ6K,EAAE2D,QA5+BY,IA4+B0B,EAAKpF,MAAM5F,QAC/CvD,EACJ4K,EAAE6D,QA7+BW,EA6+B0B,EAAKtF,MAAM3F,QAkDpD,OAjDAqM,EAAiBzR,SAAQ,SAAAP,GACvB,OAAQ+Q,GACN,IAAK,KACH/Q,EAAQqD,OAASrD,EAAQkC,EAAIyP,EAC7B3R,EAAQuD,QAAUvD,EAAQmC,EAAIyP,EAC9B5R,EAAQkC,EAAIyP,EACZ3R,EAAQmC,EAAIyP,EACZ,MACF,IAAK,KACH5R,EAAQqD,MAAQsO,EAAQ3R,EAAQkC,EAChClC,EAAQuD,QAAUvD,EAAQmC,EAAIyP,EAC9B5R,EAAQmC,EAAIyP,EACZ,MACF,IAAK,KACH5R,EAAQqD,OAASrD,EAAQkC,EAAIyP,EAC7B3R,EAAQkC,EAAIyP,EACZ3R,EAAQuD,OAASqO,EAAQ5R,EAAQmC,EACjC,MACF,IAAK,KACHnC,EAAQqD,OAASnB,EAAIyP,EACjB5E,EAAEZ,SACJnM,EAAQuD,OAASvD,EAAQqD,MAEzBrD,EAAQuD,QAAUpB,EAAIyP,EAExB,MACF,IAAK,IACH5R,EAAQuD,QAAUvD,EAAQmC,EAAIyP,EAC9B5R,EAAQmC,EAAIyP,EACZ,MACF,IAAK,IACH5R,EAAQqD,OAASrD,EAAQkC,EAAIyP,EAC7B3R,EAAQkC,EAAIyP,EACZ,MACF,IAAK,IACH3R,EAAQuD,OAASqO,EAAQ5R,EAAQmC,EACjC,MACF,IAAK,IACHnC,EAAQqD,MAAQsO,EAAQ3R,EAAQkC,EAIpC6P,EAAG7P,EAAIlC,EAAQkC,EACf6P,EAAG5P,EAAInC,EAAQmC,EACfkH,EAAa0I,MAEfJ,EAAQzP,EACR0P,EAAQzP,OACR,EAAK2J,eAKT,GAAIkF,EAAoB,CACtB,IAAMgB,EAAmBnS,EAASwF,QAAO,SAAA0M,GAAE,OAAIA,EAAGnK,cAClD,GAAIoK,EAAiBpR,OAAQ,CAC3B,IAAMsB,EAAI6K,EAAE2D,QAAU9H,EAAO+H,WAAa,EAAKrF,MAAM5F,QAC/CvD,EAAI4K,EAAE6D,QAAUhI,EAAOiI,UAAY,EAAKvF,MAAM3F,QAQpD,OAPAqM,EAAiBzR,SAAQ,SAAAP,GACvBA,EAAQkC,GAAKA,EAAIyP,EACjB3R,EAAQmC,GAAKA,EAAIyP,KAEnBD,EAAQzP,EACR0P,EAAQzP,OACR,EAAK2J,eAOT,IAAMP,EAAkB,EAAKD,MAAMC,gBACnC,GAAKA,EAAL,CACA,IAAIlI,EACF0J,EAAE2D,QAzjCgB,IA2jClBnF,EAAgBrJ,EAChB,EAAKoJ,MAAM5F,QACTnC,EACFwJ,EAAE6D,QA7jCe,EA+jCjBrF,EAAgBpJ,EAChB,EAAKmJ,MAAM3F,QACb4F,EAAgBlI,MAAQA,EAExBkI,EAAgBhI,OAASwJ,EAAEZ,SAAW9I,EAAQE,EAE9C8F,EAAakC,GAEkB,cAA3B,EAAKD,MAAMG,aA7qB7B,SAAsBwG,GACpB,IAAMC,EAAc7N,EAAqB4N,GACnCE,EAAc7N,EAAqB2N,GACnCG,EAAc7N,EAAqB0N,GACnCI,EAAc7N,EAAqByN,GACzCpS,EAASU,SAAQ,SAAAP,GACf,IAAMsG,EAAYjC,EAAqBrE,GACjCuG,EAAYjC,EAAqBtE,GACjCwG,EAAYjC,EAAqBvE,GACjCyG,EAAYjC,EAAqBxE,GACvCA,EAAQ4H,WACW,cAAjB5H,EAAQkD,MACRgP,GAAe5L,GACf8L,GAAe5L,GACf2L,GAAe5L,GACf8L,GAAe5L,KA+pBL6L,CAAa/G,GAEf,EAAKO,iBAkCPa,OAAOQ,iBAAiB,YAAa0E,GACrClF,OAAOQ,iBAAiB,WAhCN,SAAZoF,EAAaxF,GAAmB,IAAD,EACM,EAAKzB,MAAtCC,EAD2B,EAC3BA,gBAAiBE,EADU,EACVA,YAQzB,GANAkB,OAAOiB,oBAAoB,YAAaiE,GACxClF,OAAOiB,oBAAoB,UAAW2E,GAEtCrF,SAASiE,gBAAgB7B,MAAM8B,OAASF,EAGhB,OAApB3F,EAGF,OAFAnB,SACA,EAAK0B,cAIa,cAAhBL,GACEuF,IACFA,GAAqB,GAEvBnR,EAAS2S,OAETjH,EAAgB3D,YAAa,EAG/B,EAAK6E,SAAS,CACZlB,gBAAiB,KACjBE,YAAa,cAEf,EAAKK,iBAMP,EAAKA,qB,2CAprBjB,IAAcR,EAqsBV1E,EAAYC,GAAIC,GAAQ,CACtBpB,QAAS0H,KAAK9B,MAAM5F,QACpBC,QAASyH,KAAK9B,MAAM3F,QACpB2B,oBAAqB8F,KAAK9B,MAAMhE,sBAxsBxBgE,EA0sBL8B,KAAK9B,MAzsBZiC,aAAakF,QAlpBW,aAkpBgBhF,KAAKQ,UAAUpO,IACvD0N,aAAakF,QAlpBiB,mBAkpBgBhF,KAAKQ,UAAU3C,Q,GA+H7CoH,IAAMC,WA6kBlBC,GAAc1F,SAAS2F,eAAe,QAC5CC,IAASC,OAAO,kBAAC,GAAD,MAASH,IACzB,IAAM9L,GAASoG,SAAS2F,eAAe,UACjChM,GAAK4B,IAAM3B,OAAOA,IAClBK,GAAUL,GAAOM,WAAW,MAIlCD,GAAQyC,UAAU,GAAK,IAEvBkJ,IAASC,OAAO,kBAAC,GAAD,MAASH,M","file":"static/js/main.49f9f210.chunk.js","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n}\n\nexport function moveOneRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n  let isSorted = true;\n\n  // We go from right to left to avoid overriding the wrong elements\n  reversedIndicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index + 1, index);\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beggining\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beggining\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\nexport function moveAllRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a\n  );\n\n  // Copy the elements to move\n  const rightMostElements = reversedIndicesToMove.map(index => elements[index]);\n\n  indicesToMove = reversedIndicesToMove\n    // We go from left to right to avoid overriding elements.\n    .reverse()\n    // We last element index for the final marker\n    .concat([elements.length]);\n\n  indicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the left (i - 1) to the current one (index)\n    for (let pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  });\n\n  // The final step\n  rightMostElements.forEach((element, i) => {\n    elements[elements.length - i - 1] = element;\n  });\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport rough from \"roughjs/bin/wrappers/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\n\nimport { moveOneLeft, moveAllLeft, moveOneRight, moveAllRight } from \"./zindex\";\n\nimport \"./styles.scss\";\n\ntype ExcalidrawElement = ReturnType<typeof newElement>;\ntype ExcalidrawTextElement = ExcalidrawElement & {\n  type: \"text\";\n  font: string;\n  text: string;\n  actualBoundingBoxAscent: number;\n};\n\nconst LOCAL_STORAGE_KEY = \"excalidraw\";\nconst LOCAL_STORAGE_KEY_STATE = \"excalidraw-state\";\n\nconst elements = Array.of<ExcalidrawElement>();\n\n// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316\nconst LCG = (seed: number) => () =>\n  ((2 ** 31 - 1) & (seed = Math.imul(48271, seed))) / 2 ** 31;\n\nfunction randomSeed() {\n  return Math.floor(Math.random() * 2 ** 31);\n}\n\n// Unfortunately, roughjs doesn't support a seed attribute (https://github.com/pshihn/rough/issues/27).\n// We can achieve the same result by overriding the Math.random function with a\n// pseudo random generator that supports a random seed and swapping it back after.\nfunction withCustomMathRandom<T>(seed: number, cb: () => T): T {\n  const random = Math.random;\n  Math.random = LCG(seed);\n  const result = cb();\n  Math.random = random;\n  return result;\n}\n\n// https://stackoverflow.com/a/6853926/232122\nfunction distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nfunction hitTest(element: ExcalidrawElement, x: number, y: number): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = element.width / 2;\n    const b = element.height / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\nfunction resizeTest(\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n  sceneState: SceneState\n): string | false {\n  if (element.type === \"text\" || element.type === \"arrow\") return false;\n\n  const handlers = handlerRectangles(element, sceneState);\n\n  const filter = Object.keys(handlers).filter(key => {\n    const handler = handlers[key];\n\n    return (\n      x + sceneState.scrollX >= handler[0] &&\n      x + sceneState.scrollX <= handler[0] + handler[2] &&\n      y + sceneState.scrollY >= handler[1] &&\n      y + sceneState.scrollY <= handler[1] + handler[3]\n    );\n  });\n\n  if (filter.length > 0) {\n    return filter[0];\n  }\n\n  return false;\n}\n\nfunction newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    type: type,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    isSelected: false,\n    strokeColor: strokeColor,\n    backgroundColor: backgroundColor,\n    seed: randomSeed(),\n    draw(\n      rc: RoughCanvas,\n      context: CanvasRenderingContext2D,\n      sceneState: SceneState\n    ) {}\n  };\n  return element;\n}\n\ntype SceneState = {\n  scrollX: number;\n  scrollY: number;\n  // null indicates transparent bg\n  viewBackgroundColor: string | null;\n};\n\nconst SCROLLBAR_WIDTH = 6;\nconst SCROLLBAR_MARGIN = 4;\nconst SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\nconst CANVAS_WINDOW_OFFSET_LEFT = 250;\nconst CANVAS_WINDOW_OFFSET_TOP = 0;\n\nfunction getScrollbars(\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  // horizontal scrollbar\n  const sceneWidth = canvasWidth + Math.abs(scrollX);\n  const scrollBarWidth = (canvasWidth * canvasWidth) / sceneWidth;\n  const scrollBarX = scrollX > 0 ? 0 : canvasWidth - scrollBarWidth;\n  const horizontalScrollBar = {\n    x: scrollBarX + SCROLLBAR_MARGIN,\n    y: canvasHeight - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n    width: scrollBarWidth - SCROLLBAR_MARGIN * 2,\n    height: SCROLLBAR_WIDTH\n  };\n\n  // vertical scrollbar\n  const sceneHeight = canvasHeight + Math.abs(scrollY);\n  const scrollBarHeight = (canvasHeight * canvasHeight) / sceneHeight;\n  const scrollBarY = scrollY > 0 ? 0 : canvasHeight - scrollBarHeight;\n  const verticalScrollBar = {\n    x: canvasWidth - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n    y: scrollBarY + SCROLLBAR_MARGIN,\n    width: SCROLLBAR_WIDTH,\n    height: scrollBarHeight - SCROLLBAR_WIDTH * 2\n  };\n\n  return {\n    horizontal: horizontalScrollBar,\n    vertical: verticalScrollBar\n  };\n}\n\nfunction handlerRectangles(element: ExcalidrawElement, sceneState: SceneState) {\n  const elementX1 = element.x;\n  const elementX2 = element.x + element.width;\n  const elementY1 = element.y;\n  const elementY2 = element.y + element.height;\n\n  const margin = 4;\n  const minimumSize = 40;\n  const handlers: { [handler: string]: number[] } = {};\n\n  const marginX = element.width < 0 ? 8 : -8;\n  const marginY = element.height < 0 ? 8 : -8;\n\n  if (Math.abs(elementX2 - elementX1) > minimumSize) {\n    handlers[\"n\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY1 - margin + sceneState.scrollY + marginY,\n      8,\n      8\n    ];\n\n    handlers[\"s\"] = [\n      elementX1 + (elementX2 - elementX1) / 2 + sceneState.scrollX - 4,\n      elementY2 - margin + sceneState.scrollY - marginY,\n      8,\n      8\n    ];\n  }\n\n  if (Math.abs(elementY2 - elementY1) > minimumSize) {\n    handlers[\"w\"] = [\n      elementX1 - margin + sceneState.scrollX + marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n\n    handlers[\"e\"] = [\n      elementX2 - margin + sceneState.scrollX - marginX,\n      elementY1 + (elementY2 - elementY1) / 2 + sceneState.scrollY - 4,\n      8,\n      8\n    ];\n  }\n\n  handlers[\"nw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // nw\n  handlers[\"ne\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY1 - margin + sceneState.scrollY + marginY,\n    8,\n    8\n  ]; // ne\n  handlers[\"sw\"] = [\n    elementX1 - margin + sceneState.scrollX + marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // sw\n  handlers[\"se\"] = [\n    elementX2 - margin + sceneState.scrollX - marginX,\n    elementY2 - margin + sceneState.scrollY - marginY,\n    8,\n    8\n  ]; // se\n\n  return handlers;\n}\n\nfunction renderScene(\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    offsetX,\n    offsetY,\n    renderScrollbars = true,\n    renderSelection = true\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n  } = {}\n) {\n  if (!canvas) return;\n  const context = canvas.getContext(\"2d\")!;\n\n  const fillStyle = context.fillStyle;\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(-0.5, -0.5, canvas.width, canvas.height);\n  } else {\n    context.clearRect(-0.5, -0.5, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  const selectedIndices = getSelectedIndices();\n\n  sceneState = {\n    ...sceneState,\n    scrollX: typeof offsetX === \"number\" ? offsetX : sceneState.scrollX,\n    scrollY: typeof offsetY === \"number\" ? offsetY : sceneState.scrollY\n  };\n\n  elements.forEach(element => {\n    element.draw(rc, context, sceneState);\n    if (renderSelection && element.isSelected) {\n      const margin = 4;\n\n      const elementX1 = getElementAbsoluteX1(element);\n      const elementX2 = getElementAbsoluteX2(element);\n      const elementY1 = getElementAbsoluteY1(element);\n      const elementY2 = getElementAbsoluteY2(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin + sceneState.scrollX,\n        elementY1 - margin + sceneState.scrollY,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n\n      if (\n        element.type !== \"text\" &&\n        element.type !== \"arrow\" &&\n        selectedIndices.length === 1\n      ) {\n        const handlers = handlerRectangles(element, sceneState);\n        Object.values(handlers).forEach(handler => {\n          context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n        });\n      }\n    }\n  });\n\n  if (renderScrollbars) {\n    const scrollBars = getScrollbars(\n      context.canvas.width,\n      context.canvas.height,\n      sceneState.scrollX,\n      sceneState.scrollY\n    );\n\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.fillRect(\n      scrollBars.horizontal.x,\n      scrollBars.horizontal.y,\n      scrollBars.horizontal.width,\n      scrollBars.horizontal.height\n    );\n    context.fillRect(\n      scrollBars.vertical.x,\n      scrollBars.vertical.y,\n      scrollBars.vertical.width,\n      scrollBars.vertical.height\n    );\n    context.fillStyle = fillStyle;\n  }\n}\n\nfunction exportAsPNG({\n  exportBackground,\n  exportPadding = 10,\n  viewBackgroundColor\n}: {\n  exportBackground: boolean;\n  exportPadding?: number;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n}) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n\n  // calculate smallest area to fit the contents in\n\n  let subCanvasX1 = Infinity;\n  let subCanvasX2 = 0;\n  let subCanvasY1 = Infinity;\n  let subCanvasY2 = 0;\n\n  elements.forEach(element => {\n    subCanvasX1 = Math.min(subCanvasX1, getElementAbsoluteX1(element));\n    subCanvasX2 = Math.max(subCanvasX2, getElementAbsoluteX2(element));\n    subCanvasY1 = Math.min(subCanvasY1, getElementAbsoluteY1(element));\n    subCanvasY2 = Math.max(subCanvasY2, getElementAbsoluteY2(element));\n  });\n\n  function distance(x: number, y: number) {\n    return Math.abs(x > y ? x - y : y - x);\n  }\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  tempCanvas.width = distance(subCanvasX1, subCanvasX2) + exportPadding * 2;\n  tempCanvas.height = distance(subCanvasY1, subCanvasY2) + exportPadding * 2;\n\n  renderScene(\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: 0,\n      scrollY: 0\n    },\n    {\n      offsetX: -subCanvasX1 + exportPadding,\n      offsetY: -subCanvasY1 + exportPadding,\n      renderScrollbars: false,\n      renderSelection: false\n    }\n  );\n\n  // create a temporary <a> elem which we'll use to download the image\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"download\", \"excalidraw.png\");\n  link.setAttribute(\"href\", tempCanvas.toDataURL(\"image/png\"));\n  link.click();\n\n  // clean up the DOM\n  link.remove();\n  if (tempCanvas !== canvas) tempCanvas.remove();\n}\n\nfunction rotate(x1: number, y1: number, x2: number, y2: number, angle: number) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nconst generator = rough.generator(null, null as any);\n\nfunction isTextElement(\n  element: ExcalidrawElement\n): element is ExcalidrawTextElement {\n  return element.type === \"text\";\n}\n\nfunction isInputLike(\n  target: Element | EventTarget | null\n): target is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\n  return (\n    target instanceof HTMLInputElement ||\n    target instanceof HTMLTextAreaElement ||\n    target instanceof HTMLSelectElement\n  );\n}\n\nfunction getArrowPoints(element: ExcalidrawElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n\nfunction generateDraw(element: ExcalidrawElement) {\n  if (element.type === \"selection\") {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(\n        element.x + scrollX,\n        element.y + scrollY,\n        element.width,\n        element.height\n      );\n      context.fillStyle = fillStyle;\n    };\n  } else if (element.type === \"rectangle\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      return generator.rectangle(0, 0, element.width, element.height, {\n        stroke: element.strokeColor,\n        fill: element.backgroundColor\n      });\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n  } else if (element.type === \"ellipse\") {\n    const shape = withCustomMathRandom(element.seed, () =>\n      generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        { stroke: element.strokeColor, fill: element.backgroundColor }\n      )\n    );\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const shapes = withCustomMathRandom(element.seed, () => [\n      //    \\\n      generator.line(x3, y3, x2, y2, { stroke: element.strokeColor }),\n      // -----\n      generator.line(x1, y1, x2, y2, { stroke: element.strokeColor }),\n      //    /\n      generator.line(x4, y4, x2, y2, { stroke: element.strokeColor })\n    ]);\n\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      shapes.forEach(shape => rc.draw(shape));\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n    return;\n  } else if (isTextElement(element)) {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const font = context.font;\n      context.font = element.font;\n      const fillStyle = context.fillStyle;\n      context.fillStyle = element.strokeColor;\n      context.fillText(\n        element.text,\n        element.x + scrollX,\n        element.y + element.actualBoundingBoxAscent + scrollY\n      );\n      context.fillStyle = fillStyle;\n      context.font = font;\n    };\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nfunction getElementAbsoluteX1(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x : element.x + element.width;\n}\nfunction getElementAbsoluteX2(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x + element.width : element.x;\n}\nfunction getElementAbsoluteY1(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y : element.y + element.height;\n}\nfunction getElementAbsoluteY2(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y + element.height : element.y;\n}\n\nfunction setSelection(selection: ExcalidrawElement) {\n  const selectionX1 = getElementAbsoluteX1(selection);\n  const selectionX2 = getElementAbsoluteX2(selection);\n  const selectionY1 = getElementAbsoluteY1(selection);\n  const selectionY2 = getElementAbsoluteY2(selection);\n  elements.forEach(element => {\n    const elementX1 = getElementAbsoluteX1(element);\n    const elementX2 = getElementAbsoluteX2(element);\n    const elementY1 = getElementAbsoluteY1(element);\n    const elementY2 = getElementAbsoluteY2(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nfunction clearSelection() {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nfunction deleteSelectedElements() {\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\nfunction save(state: AppState) {\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(elements));\n  localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(state));\n}\n\nfunction restore() {\n  try {\n    const savedElements = localStorage.getItem(LOCAL_STORAGE_KEY);\n    const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_STATE);\n\n    if (savedElements) {\n      elements.splice(0, elements.length, ...JSON.parse(savedElements));\n      elements.forEach((element: ExcalidrawElement) => generateDraw(element));\n    }\n\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (e) {\n    elements.splice(0, elements.length);\n    return null;\n  }\n}\n\ntype AppState = {\n  draggingElement: ExcalidrawElement | null;\n  resizingElement: ExcalidrawElement | null;\n  elementType: string;\n  exportBackground: boolean;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n};\n\nconst KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nconst SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\"\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\"\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\"\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\"\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\"\n  }\n];\n\nconst shapesShortcutKeys = SHAPES.map(shape => shape.value[0]);\n\nfunction findElementByKey(key: string) {\n  const defaultElement = \"selection\";\n  return SHAPES.reduce((element, shape) => {\n    if (shape.value[0] !== key) return element;\n\n    return shape.value;\n  }, defaultElement);\n}\n\nfunction isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n\nfunction getSelectedIndices() {\n  const selectedIndices: number[] = [];\n  elements.forEach((element, index) => {\n    if (element.isSelected) {\n      selectedIndices.push(index);\n    }\n  });\n  return selectedIndices;\n}\n\nconst someElementIsSelected = () =>\n  elements.some(element => element.isSelected);\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\n\nclass App extends React.Component<{}, AppState> {\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    window.addEventListener(\"resize\", this.onResize, false);\n\n    const savedState = restore();\n    if (savedState) {\n      this.setState(savedState);\n    }\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    window.removeEventListener(\"resize\", this.onResize, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    resizingElement: null,\n    elementType: \"selection\",\n    exportBackground: true,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    viewBackgroundColor: \"#ffffff\",\n    scrollX: 0,\n    scrollY: 0\n  };\n\n  private onResize = () => {\n    this.forceUpdate();\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (isInputLike(event.target)) return;\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      deleteSelectedElements();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send backward: Cmd-Shift-Alt-B\n    } else if (\n      event.metaKey &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyB\"\n    ) {\n      this.moveOneLeft();\n      event.preventDefault();\n\n      // Send to back: Cmd-Shift-B\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyB\") {\n      this.moveAllLeft();\n      event.preventDefault();\n\n      // Bring forward: Cmd-Shift-Alt-F\n    } else if (\n      event.metaKey &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyF\"\n    ) {\n      this.moveOneRight();\n      event.preventDefault();\n\n      // Bring to front: Cmd-Shift-F\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyF\") {\n      this.moveAllRight();\n      event.preventDefault();\n\n      // Select all: Cmd-A\n    } else if (event.metaKey && event.code === \"KeyA\") {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n      this.setState({ elementType: findElementByKey(event.key) });\n    }\n  };\n\n  private deleteSelectedElements = () => {\n    deleteSelectedElements();\n    this.forceUpdate();\n  };\n\n  private clearCanvas = () => {\n    if (window.confirm(\"This will clear the whole canvas. Are you sure?\")) {\n      elements.splice(0, elements.length);\n      this.setState({\n        viewBackgroundColor: \"#ffffff\",\n        scrollX: 0,\n        scrollY: 0\n      });\n      this.forceUpdate();\n    }\n  };\n\n  private moveAllLeft = () => {\n    moveAllLeft(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveOneLeft = () => {\n    moveOneLeft(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveAllRight = () => {\n    moveAllRight(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private moveOneRight = () => {\n    moveOneRight(elements, getSelectedIndices());\n    this.forceUpdate();\n  };\n\n  private removeWheelEventListener: (() => void) | undefined;\n\n  public render() {\n    return (\n      <div\n        className=\"container\"\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements();\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          let parsedElements;\n          try {\n            parsedElements = JSON.parse(paste);\n          } catch (e) {}\n          if (\n            Array.isArray(parsedElements) &&\n            parsedElements.length > 0 &&\n            parsedElements[0].type // need to implement a better check here...\n          ) {\n            clearSelection();\n            parsedElements.forEach(parsedElement => {\n              parsedElement.x += 10;\n              parsedElement.y += 10;\n              parsedElement.seed = randomSeed();\n              generateDraw(parsedElement);\n              elements.push(parsedElement);\n            });\n            this.forceUpdate();\n          }\n          e.preventDefault();\n        }}\n      >\n        <div className=\"sidePanel\">\n          <h4>Shapes</h4>\n          <div className=\"panelTools\">\n            {SHAPES.map(({ value, icon }) => (\n              <label key={value} className=\"tool\">\n                <input\n                  type=\"radio\"\n                  checked={this.state.elementType === value}\n                  onChange={() => {\n                    this.setState({ elementType: value });\n                    clearSelection();\n                    this.forceUpdate();\n                  }}\n                />\n                <div className=\"toolIcon\">{icon}</div>\n              </label>\n            ))}\n          </div>\n          <h4>Colors</h4>\n          <div className=\"panelColumn\">\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.viewBackgroundColor}\n                onChange={e => {\n                  this.setState({ viewBackgroundColor: e.target.value });\n                }}\n              />\n              Background\n            </label>\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.currentItemStrokeColor}\n                onChange={e => {\n                  this.setState({ currentItemStrokeColor: e.target.value });\n                }}\n              />\n              Shape Stroke\n            </label>\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.currentItemBackgroundColor}\n                onChange={e => {\n                  this.setState({ currentItemBackgroundColor: e.target.value });\n                }}\n              />\n              Shape Background\n            </label>\n          </div>\n          <h4>Canvas</h4>\n          <div className=\"panelColumn\">\n            <button\n              onClick={this.clearCanvas}\n              title=\"Clear the canvas & reset background color\"\n            >\n              Clear canvas\n            </button>\n          </div>\n          <h4>Export</h4>\n          <div className=\"panelColumn\">\n            <button\n              onClick={() => {\n                exportAsPNG(this.state);\n              }}\n            >\n              Export to png\n            </button>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={this.state.exportBackground}\n                onChange={e => {\n                  this.setState({ exportBackground: e.target.checked });\n                }}\n              />\n              background\n            </label>\n          </div>\n          {someElementIsSelected() && (\n            <>\n              <h4>Shape options</h4>\n              <div className=\"panelColumn\">\n                <button onClick={this.deleteSelectedElements}>Delete</button>\n                <button onClick={this.moveOneRight}>Bring forward</button>\n                <button onClick={this.moveAllRight}>Bring to front</button>\n                <button onClick={this.moveOneLeft}>Send backward</button>\n                <button onClick={this.moveAllLeft}>Send to back</button>\n              </div>\n            </>\n          )}\n        </div>\n        <canvas\n          id=\"canvas\"\n          width={window.innerWidth - CANVAS_WINDOW_OFFSET_LEFT}\n          height={window.innerHeight - CANVAS_WINDOW_OFFSET_TOP}\n          ref={canvas => {\n            if (this.removeWheelEventListener) {\n              this.removeWheelEventListener();\n              this.removeWheelEventListener = undefined;\n            }\n            if (canvas) {\n              canvas.addEventListener(\"wheel\", this.handleWheel, {\n                passive: false\n              });\n              this.removeWheelEventListener = () =>\n                canvas.removeEventListener(\"wheel\", this.handleWheel);\n            }\n          }}\n          onMouseDown={e => {\n            // only handle left mouse button\n            if (e.button !== 0) return;\n            // fixes mousemove causing selection of UI texts #32\n            e.preventDefault();\n            // Preventing the event above disables default behavior\n            //  of defocusing potentially focused input, which is what we want\n            //  when clicking inside the canvas.\n            if (isInputLike(document.activeElement)) {\n              document.activeElement.blur();\n            }\n\n            const x =\n              e.clientX -\n              (e.target as HTMLElement).offsetLeft -\n              this.state.scrollX;\n            const y =\n              e.clientY -\n              (e.target as HTMLElement).offsetTop -\n              this.state.scrollY;\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor\n            );\n            let resizeHandle: string | false = false;\n            let isDraggingElements = false;\n            let isResizingElements = false;\n            const cursorStyle = document.documentElement.style.cursor;\n            if (this.state.elementType === \"selection\") {\n              const resizeElement = elements.find(element => {\n                return resizeTest(element, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n              });\n\n              this.setState({\n                resizingElement: resizeElement ? resizeElement : null\n              });\n\n              if (resizeElement) {\n                resizeHandle = resizeTest(resizeElement, x, y, {\n                  scrollX: this.state.scrollX,\n                  scrollY: this.state.scrollY,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n                document.documentElement.style.cursor = `${resizeHandle}-resize`;\n                isResizingElements = true;\n              } else {\n                let hitElement = null;\n                // We need to to hit testing from front (end of the array) to back (beginning of the array)\n                for (let i = elements.length - 1; i >= 0; --i) {\n                  if (hitTest(elements[i], x, y)) {\n                    hitElement = elements[i];\n                    break;\n                  }\n                }\n\n                // If we click on something\n                if (hitElement) {\n                  if (hitElement.isSelected) {\n                    // If that element is not already selected, do nothing,\n                    // we're likely going to drag it\n                  } else {\n                    // We unselect every other elements unless shift is pressed\n                    if (!e.shiftKey) {\n                      clearSelection();\n                    }\n                    // No matter what, we select it\n                    hitElement.isSelected = true;\n                  }\n                } else {\n                  // If we don't click on anything, let's remove all the selected elements\n                  clearSelection();\n                }\n\n                isDraggingElements = someElementIsSelected();\n\n                if (isDraggingElements) {\n                  document.documentElement.style.cursor = \"move\";\n                }\n              }\n            }\n\n            if (isTextElement(element)) {\n              const text = prompt(\"What text do you want?\");\n              if (text === null) {\n                return;\n              }\n              element.text = text;\n              element.font = \"20px Virgil\";\n              const font = context.font;\n              context.font = element.font;\n              const {\n                actualBoundingBoxAscent,\n                actualBoundingBoxDescent,\n                width\n              } = context.measureText(element.text);\n              element.actualBoundingBoxAscent = actualBoundingBoxAscent;\n              context.font = font;\n              const height = actualBoundingBoxAscent + actualBoundingBoxDescent;\n              // Center the text\n              element.x -= width / 2;\n              element.y -= actualBoundingBoxAscent;\n              element.width = width;\n              element.height = height;\n            }\n\n            generateDraw(element);\n            elements.push(element);\n            if (this.state.elementType === \"text\") {\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              element.isSelected = true;\n            } else {\n              this.setState({ draggingElement: element });\n            }\n\n            let lastX = x;\n            let lastY = y;\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isResizingElements && this.state.resizingElement) {\n                const el = this.state.resizingElement;\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length === 1) {\n                  const x =\n                    e.clientX - CANVAS_WINDOW_OFFSET_LEFT - this.state.scrollX;\n                  const y =\n                    e.clientY - CANVAS_WINDOW_OFFSET_TOP - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    switch (resizeHandle) {\n                      case \"nw\":\n                        element.width += element.x - lastX;\n                        element.height += element.y - lastY;\n                        element.x = lastX;\n                        element.y = lastY;\n                        break;\n                      case \"ne\":\n                        element.width = lastX - element.x;\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"sw\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        element.height = lastY - element.y;\n                        break;\n                      case \"se\":\n                        element.width += x - lastX;\n                        if (e.shiftKey) {\n                          element.height = element.width;\n                        } else {\n                          element.height += y - lastY;\n                        }\n                        break;\n                      case \"n\":\n                        element.height += element.y - lastY;\n                        element.y = lastY;\n                        break;\n                      case \"w\":\n                        element.width += element.x - lastX;\n                        element.x = lastX;\n                        break;\n                      case \"s\":\n                        element.height = lastY - element.y;\n                        break;\n                      case \"e\":\n                        element.width = lastX - element.x;\n                        break;\n                    }\n\n                    el.x = element.x;\n                    el.y = element.y;\n                    generateDraw(el);\n                  });\n                  lastX = x;\n                  lastY = y;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const x = e.clientX - target.offsetLeft - this.state.scrollX;\n                  const y = e.clientY - target.offsetTop - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width =\n                e.clientX -\n                CANVAS_WINDOW_OFFSET_LEFT -\n                draggingElement.x -\n                this.state.scrollX;\n              let height =\n                e.clientY -\n                CANVAS_WINDOW_OFFSET_TOP -\n                draggingElement.y -\n                this.state.scrollY;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey ? width : height;\n\n              generateDraw(draggingElement);\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(draggingElement);\n              }\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              document.documentElement.style.cursor = cursorStyle;\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection();\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            this.forceUpdate();\n          }}\n        />\n      </div>\n    );\n  }\n\n  private handleWheel = (e: WheelEvent) => {\n    e.preventDefault();\n    const { deltaX, deltaY } = e;\n    this.setState(state => ({\n      scrollX: state.scrollX - deltaX,\n      scrollY: state.scrollY - deltaY\n    }));\n  };\n\n  componentDidUpdate() {\n    renderScene(rc, canvas, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor\n    });\n    save(this.state);\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst rc = rough.canvas(canvas);\nconst context = canvas.getContext(\"2d\")!;\n\n// Big hack to ensure that all the 1px lines are drawn at 1px instead of 2px\n// https://stackoverflow.com/questions/13879322/drawing-a-1px-thick-line-in-canvas-creates-a-2px-thick-line/13879402#comment90766599_13879402\ncontext.translate(0.5, 0.5);\n\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}